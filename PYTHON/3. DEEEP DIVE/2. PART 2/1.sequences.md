- [SEQUENCE TYPES](#types)
- [MUTABLE SEQUENCE TYPES](#mutable)
- [LISTS VS TUPLES](#list-tuples)
- [COPYING SEQUENCES](#copying)
- [SLICING](#slicing)
- [CUSTOM SEQUENCES](#custom)
- [IN PLACE CONCATENATION AND REPETITION](#in-place)
- [ASSIGNMENTS IN MUTABLE SEQUENCES](#assignments)
- [SORTING SEQUENCES](#sorting)
- [LIST COMPREHENSION](#list-comprehension)
  
<a id='types'></a>
# Python Sequence Types

Sequences in Python are an essential category of data structures that allow you to store multiple items in an ordered way. They include strings, lists, tuples, ranges, and more. Understanding sequence types is key to working effectively with Python.

---

## 1. **What Are Sequences?**
- A **sequence** is an ordered collection of items.
- Sequences support common operations like indexing, slicing, and iteration.
- Common sequence types in Python include:
  - Strings (`str`)
  - Lists (`list`)
  - Tuples (`tuple`)
  - Ranges (`range`)
  - Byte sequences (`bytes`, `bytearray`)

---

## 2. **Immutable Sequence Types**
Immutable sequences cannot be modified after creation.

### 2.1 Strings (`str`)
- A string is a sequence of characters.
- Immutable and supports operations like slicing, concatenation, and iteration.

#### Example:
```python
text = "hello"
print(text[1])         # Output: 'e'
print(text[1:4])       # Output: 'ell'
print(text.upper())    # Output: 'HELLO'
```

### 2.2 Tuples (`tuple`)
- A tuple is an immutable sequence of items, often used for fixed collections of related data.

#### Example:
```python
data = (1, 2, 3)
print(data[0])         # Output: 1
print(data[:2])        # Output: (1, 2)
```

### 2.3 Ranges (`range`)
- Represents a sequence of numbers, typically used in loops.
- Immutable and memory-efficient.

#### Example:
```python
nums = range(1, 5)
print(list(nums))      # Output: [1, 2, 3, 4]
```

---

## 3. **Mutable Sequence Types**
Mutable sequences can be modified after creation.

### 3.1 Lists (`list`)
- A list is a dynamic sequence that can hold items of mixed types.
- Supports modifications like adding, removing, or replacing elements.

#### Example:
```python
items = [1, 2, 3]
items.append(4)
print(items)           # Output: [1, 2, 3, 4]
items[0] = 10
print(items)           # Output: [10, 2, 3, 4]
```

### 3.2 Byte Arrays (`bytearray`)
- Mutable sequence of bytes.
- Useful for binary data manipulation.

#### Example:
```python
ba = bytearray(b"hello")
ba[0] = 72
print(ba)              # Output: bytearray(b'Hello')
```

---

## 4. **Common Sequence Operations**

### 4.1 Indexing
Access elements by their position (starting from 0).
```python
data = [10, 20, 30]
print(data[1])          # Output: 20
```

### 4.2 Slicing
Extract subsequences using the `start:stop[:step]` syntax.
```python
nums = [0, 1, 2, 3, 4]
print(nums[1:4])        # Output: [1, 2, 3]
```

### 4.3 Concatenation
Combine two sequences of the same type.
```python
list1 = [1, 2]
list2 = [3, 4]
print(list1 + list2)    # Output: [1, 2, 3, 4]
```

### 4.4 Iteration
Iterate through each item in the sequence.
```python
for char in "abc":
    print(char)
```

### 4.5 Membership Testing
Check if an item exists in a sequence.
```python
nums = [1, 2, 3]
print(2 in nums)        # Output: True
```

### 4.6 Length, Min, and Max
Functions to get sequence properties.
```python
nums = [1, 2, 3]
print(len(nums))        # Output: 3
print(min(nums))        # Output: 1
print(max(nums))        # Output: 3
```

---

## 5. **Advanced Sequence Features**

### 5.1 List Comprehensions
A concise way to create new lists.
```python
squares = [x**2 for x in range(5)]
print(squares)          # Output: [0, 1, 4, 9, 16]
```

### 5.2 Tuple Packing and Unpacking
Group values into a tuple and extract them into variables.
```python
point = (10, 20)
x, y = point
print(x, y)            # Output: 10 20
```

### 5.3 Reversed Iteration
Iterate over a sequence in reverse order.
```python
nums = [1, 2, 3]
for n in reversed(nums):
    print(n)           # Output: 3, 2, 1
```

### 5.4 Sorted Sequences
Return a new sorted list from a sequence.
```python
nums = [3, 1, 2]
print(sorted(nums))    # Output: [1, 2, 3]
```

---

## 6. **Best Practices**
1. **Choose the Right Sequence:**
   - Use `list` for dynamic data.
   - Use `tuple` for fixed, immutable collections.
   - Use `range` for large numeric sequences.

2. **Use List Comprehensions:**
   - Prefer list comprehensions over loops for cleaner code.

3. **Avoid Modifying Immutable Sequences:**
   - Immutable types like strings or tuples should not be modified. Create new objects instead.

---

## 7. **Conclusion**
Sequence types are fundamental to Python programming, providing powerful tools for managing collections of data. By understanding the characteristics and use cases of each sequence type, you can write cleaner, more efficient, and more Pythonic code.

<a id='mutable'></a>
# Mutable Sequence Types in Python

Mutable sequences in Python are collections of items that can be modified after their creation. They allow for operations such as adding, removing, or changing elements, making them versatile for dynamic data manipulation.

---

## 1. **What Are Mutable Sequences?**
- Mutable sequences can be changed in place.
- Common operations include appending, deleting, or replacing elements.
- Examples of mutable sequences in Python:
  - Lists (`list`)
  - Byte arrays (`bytearray`)
  - Mutable strings (`collections.UserString`, though not common in practice).

---

## 2. **List (`list`)

### Characteristics:
- Ordered collection of items.
- Items can be of mixed types.
- Supports dynamic resizing.

### Example:
```python
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)  # Output: [1, 2, 3, 4]

numbers[1] = 10
print(numbers)  # Output: [1, 10, 3, 4]
```

### Key Operations:
1. **Adding Items:**
   - `append(item)` adds an item to the end.
   - `extend(iterable)` adds multiple items.
   ```python
   items = [1, 2]
   items.extend([3, 4])
   print(items)  # Output: [1, 2, 3, 4]
   ```

2. **Inserting Items:**
   - `insert(index, item)` adds an item at the specified position.
   ```python
   items = [1, 3]
   items.insert(1, 2)
   print(items)  # Output: [1, 2, 3]
   ```

3. **Removing Items:**
   - `remove(item)` removes the first occurrence of the item.
   - `pop(index)` removes and returns the item at the specified index.
   ```python
   items = [1, 2, 3]
   items.pop(1)
   print(items)  # Output: [1, 3]
   ```

4. **Sorting and Reversing:**
   - `sort()` sorts the list in place.
   - `reverse()` reverses the list in place.
   ```python
   items = [3, 1, 2]
   items.sort()
   print(items)  # Output: [1, 2, 3]
   ```

---

## 3. **Byte Arrays (`bytearray`)

### Characteristics:
- Mutable sequence of bytes.
- Useful for binary data manipulation.
- Each element is an integer between 0 and 255.

### Example:
```python
ba = bytearray(b"hello")
print(ba)  # Output: bytearray(b'hello')

ba[0] = 72  # ASCII for 'H'
print(ba)  # Output: bytearray(b'Hello')
```

### Key Operations:
1. **Modifying Bytes:**
   - Individual bytes can be changed by assignment.
   ```python
   ba = bytearray(b"world")
   ba[1] = 79  # ASCII for 'O'
   print(ba)  # Output: bytearray(b'wOrld')
   ```

2. **Appending and Extending:**
   - Use `append(byte)` to add a single byte.
   - Use `extend(iterable)` to add multiple bytes.
   ```python
   ba = bytearray(b"hi")
   ba.append(33)  # ASCII for '!'
   print(ba)  # Output: bytearray(b'hi!')
   ```

3. **Slicing and Deleting:**
   - Byte arrays support slicing for modification.
   ```python
   ba = bytearray(b"hello")
   ba[1:3] = b"aa"
   print(ba)  # Output: bytearray(b'haalo')
   ```

---

## 4. **Common Operations on Mutable Sequences**

### Indexing and Slicing
Access and modify elements using indices and slices.
```python
items = [10, 20, 30, 40]
items[2] = 35
print(items)  # Output: [10, 20, 35, 40]

items[1:3] = [25, 35]
print(items)  # Output: [10, 25, 35, 40]
```

### Iteration
Iterate through the sequence with a loop.
```python
for item in [1, 2, 3]:
    print(item)
```

### Membership Testing
Check if an item exists in the sequence.
```python
items = [1, 2, 3]
print(2 in items)  # Output: True
```

### Concatenation and Repetition
Combine or repeat sequences.
```python
list1 = [1, 2]
list2 = [3, 4]
print(list1 + list2)  # Output: [1, 2, 3, 4]

print(list1 * 2)     # Output: [1, 2, 1, 2]
```

---

## 5. **Best Practices for Mutable Sequences**

1. **Minimize Side Effects:**
   - Avoid modifying sequences during iteration.
   - Example of a common pitfall:
     ```python
     items = [1, 2, 3]
     for item in items:
         if item == 2:
             items.remove(item)  # Risky modification during iteration
     ```

2. **Use List Comprehensions for Clean Code:**
   - Prefer list comprehensions for transforming data.
   ```python
   numbers = [1, 2, 3, 4]
   squares = [x**2 for x in numbers]
   print(squares)  # Output: [1, 4, 9, 16]
   ```

3. **Validate Byte Ranges:**
   - Ensure values in `bytearray` operations are within the range `0-255`.

4. **Use Appropriate Sequence Types:**
   - Use `list` for general-purpose data.
   - Use `bytearray` for binary data manipulation.

---

## 6. **Conclusion**
Mutable sequences like lists and byte arrays are powerful tools for managing and manipulating dynamic collections of data. By understanding their operations and best practices, you can effectively use them to write clean, efficient, and Pythonic code.

<a id='list-tuples'></a>
# Python Lists vs Tuples

Lists and tuples are two of the most commonly used data structures in Python. While they share similarities, they also have key differences that affect how and when to use them.

---

## 1. **Overview**
| Feature               | List                             | Tuple                           |
|-----------------------|----------------------------------|---------------------------------|
| **Mutability**        | Mutable (can be changed)         | Immutable (cannot be changed)  |
| **Syntax**            | Square brackets `[ ]`           | Parentheses `( )`              |
| **Performance**       | Slower due to dynamic resizing   | Faster due to immutability     |
| **Use Case**          | When data needs modification     | For fixed collections          |

---

## 2. **Key Differences**

### 2.1 Syntax
- **Lists:**
  ```python
  my_list = [1, 2, 3]
  ```
- **Tuples:**
  ```python
  my_tuple = (1, 2, 3)
  ```

### 2.2 Mutability
- **Lists** can be modified after creation:
  ```python
  my_list = [1, 2, 3]
  my_list[0] = 10
  print(my_list)  # Output: [10, 2, 3]
  ```

- **Tuples** are immutable:
  ```python
  my_tuple = (1, 2, 3)
  # my_tuple[0] = 10  # Raises TypeError
  ```

### 2.3 Performance
- **Tuples** are faster than lists due to their immutability.
- Example:
  ```python
  import timeit

  list_creation = timeit.timeit("[1, 2, 3, 4, 5]", number=1000000)
  tuple_creation = timeit.timeit("(1, 2, 3, 4, 5)", number=1000000)

  print(f"List creation time: {list_creation}")
  print(f"Tuple creation time: {tuple_creation}")
  ```

### 2.4 Memory Usage
- **Tuples** use less memory than lists.
- Example:
  ```python
  import sys

  my_list = [1, 2, 3, 4, 5]
  my_tuple = (1, 2, 3, 4, 5)

  print(sys.getsizeof(my_list))  # Memory size of list
  print(sys.getsizeof(my_tuple)) # Memory size of tuple
  ```

### 2.5 Methods
- **Lists** have more methods for modification:
  ```python
  my_list = [1, 2, 3]
  my_list.append(4)      # Add an item
  my_list.remove(2)      # Remove an item
  my_list.sort()         # Sort the list
  ```

- **Tuples** have limited methods:
  ```python
  my_tuple = (1, 2, 3, 1)
  print(my_tuple.count(1))  # Output: 2
  print(my_tuple.index(2))  # Output: 1
  ```

### 2.6 Immutability Implications
- Tuples are **hashable** and can be used as keys in dictionaries or elements in sets.
  ```python
  my_tuple = (1, 2, 3)
  my_dict = {my_tuple: "value"}
  print(my_dict)  # Output: {(1, 2, 3): 'value'}
  ```

- Lists are **not hashable**:
  ```python
  my_list = [1, 2, 3]
  # my_dict = {my_list: "value"}  # Raises TypeError
  ```

---

## 3. **When to Use Lists**
- When the collection needs to be modified (e.g., adding, removing, or updating elements).
- Examples:
  - Dynamic datasets.
  - Storing intermediate results in algorithms.

---

## 4. **When to Use Tuples**
- When the collection is fixed and should not change.
- When immutability is desired for safety.
- Examples:
  - Coordinates (e.g., `(x, y)` pairs).
  - Return values from functions.
  - Keys in dictionaries.

---

## 5. **Examples in Practice**

### 5.1 Using a List for Dynamic Data
```python
shopping_list = ["milk", "eggs", "bread"]
shopping_list.append("butter")
print(shopping_list)  # Output: ['milk', 'eggs', 'bread', 'butter']
```

### 5.2 Using a Tuple for Fixed Data
```python
coordinates = (10.0, 20.0)
print(coordinates)  # Output: (10.0, 20.0)
```

---

## 6. **Performance Benchmarks**
### Example: Iteration Speed
```python
import timeit

list_test = timeit.timeit("for _ in [1, 2, 3, 4, 5]: pass", number=1000000)
tuple_test = timeit.timeit("for _ in (1, 2, 3, 4, 5): pass", number=1000000)

print(f"List iteration time: {list_test}")
print(f"Tuple iteration time: {tuple_test}")
```

---

## 7. **Summary Table**
| Feature               | List                              | Tuple                           |
|-----------------------|-----------------------------------|---------------------------------|
| Mutability            | Mutable                          | Immutable                      |
| Syntax                | `[ ]`                            | `( )`                          |
| Performance           | Slower due to mutability         | Faster due to immutability     |
| Memory Usage          | Higher                           | Lower                          |
| Methods               | Rich set of modification methods | Limited methods                |
| Hashable              | No                               | Yes                            |
| Common Use Cases      | Dynamic data                     | Fixed collections              |

---

## 8. **Conclusion**
Lists and tuples are both powerful sequence types in Python, each suited for different scenarios. Use lists for mutable, dynamic collections and tuples for immutable, fixed data. Understanding their differences ensures optimal performance and better code organization.

<a id='copying'></a>
# Copying Sequences in Python

Copying sequences in Python allows you to create new sequences with the same data. Understanding the difference between shallow and deep copies is critical for preventing unintended side effects when working with mutable sequences.

---

## 1. **Why Copy Sequences?**
Copying is useful when:
- You want to create a backup of a sequence.
- You want to work with the data without modifying the original sequence.
- You need to avoid accidental changes in mutable sequences.

---

## 2. **Types of Copies**

### 2.1 Shallow Copy
- Creates a new sequence object.
- Copies references to the elements from the original sequence.
- If the elements are mutable, changes to them will affect both the original and the copied sequence.

### 2.2 Deep Copy
- Creates a new sequence object.
- Recursively copies all elements, including nested structures.
- Changes to the deep-copied sequence do not affect the original.

---

## 3. **Methods for Copying Sequences**

### 3.1 Using Slicing
- Works for copying lists, strings, and tuples.
- Creates a shallow copy.

#### Example:
```python
original_list = [1, 2, 3]
copied_list = original_list[:]

print(copied_list)  # Output: [1, 2, 3]

copied_list[0] = 10
print(original_list)  # Output: [1, 2, 3] (unchanged)
```

### 3.2 Using the `copy` Method
- Available for lists.
- Creates a shallow copy.

#### Example:
```python
original_list = [1, 2, 3]
copied_list = original_list.copy()

print(copied_list)  # Output: [1, 2, 3]
```

### 3.3 Using the `list()` Constructor
- Works for creating a shallow copy of any iterable.

#### Example:
```python
original_list = [1, 2, 3]
copied_list = list(original_list)

print(copied_list)  # Output: [1, 2, 3]
```

### 3.4 Using the `copy` Module
- Provides `copy.copy` for shallow copies and `copy.deepcopy` for deep copies.

#### Example (Shallow Copy):
```python
import copy

original_list = [1, 2, 3]
copied_list = copy.copy(original_list)

print(copied_list)  # Output: [1, 2, 3]
```

#### Example (Deep Copy):
```python
import copy

original_list = [[1, 2], [3, 4]]
deep_copied_list = copy.deepcopy(original_list)

deep_copied_list[0][0] = 10
print(original_list)       # Output: [[1, 2], [3, 4]] (unchanged)
print(deep_copied_list)    # Output: [[10, 2], [3, 4]]
```

---

## 4. **Copying Immutable Sequences**
- Strings and tuples are immutable, so copying typically just creates a reference to the same object.

#### Example:
```python
original_string = "hello"
copied_string = original_string[:]

print(original_string is copied_string)  # Output: True
```
> **Note:** Copying immutable sequences is unnecessary unless a new reference is explicitly required.

---

## 5. **Nested Sequences and Copying**
- Shallow copies do not copy nested structures; only references are copied.

#### Example:
```python
original_list = [[1, 2], [3, 4]]
shallow_copy = original_list[:]

shallow_copy[0][0] = 10
print(original_list)  # Output: [[10, 2], [3, 4]]
```

- Use deep copies to handle nested sequences.

---

## 6. **Performance Considerations**
1. **Shallow Copies:** Faster because they only copy references.
2. **Deep Copies:** Slower because they recursively copy all elements.

---

## 7. **Best Practices**
1. **Use Slicing or `copy` for Flat Structures:**
   - Prefer slicing or the `copy` method for non-nested lists.

2. **Use `copy.deepcopy` for Nested Structures:**
   - Avoid unintended modifications by using deep copies for nested sequences.

3. **Avoid Unnecessary Copies:**
   - Immutable sequences like strings and tuples don’t require explicit copying unless needed for clarity.

4. **Understand Copy Implications:**
   - Be cautious when working with mutable objects in shallow copies.

---

## 8. **Conclusion**
Copying sequences in Python is a common operation that can prevent unwanted side effects and improve code clarity. By choosing the appropriate method for copying and understanding the difference between shallow and deep copies, you can manage sequences effectively in any Python project.

<a id='slicing'></a>
# Python Slicing

Slicing in Python is a powerful technique for extracting portions of sequences such as lists, strings, tuples, and other iterable types. It provides an elegant way to work with subsequences without explicitly iterating over elements.

---

## 1. **What is Slicing?**
Slicing is a mechanism to extract a portion of a sequence by specifying a range of indices. It is defined by the syntax:

### Syntax:
```python
sequence[start:stop:step]
```

### Parameters:
- **`start`**: The index to begin slicing (inclusive).
- **`stop`**: The index to end slicing (exclusive).
- **`step`**: The step size to determine how many items to skip.

---

## 2. **Basic Slicing**

### Example:
```python
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(nums[2:5])  # Output: [2, 3, 4]
```

### Omitting Parameters:
- Omitting `start`: Defaults to the beginning of the sequence.
- Omitting `stop`: Defaults to the end of the sequence.
- Omitting `step`: Defaults to `1`.

#### Example:
```python
print(nums[:5])   # Output: [0, 1, 2, 3, 4]
print(nums[5:])   # Output: [5, 6, 7, 8, 9]
print(nums[:])    # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

## 3. **Step in Slicing**
The `step` parameter allows you to skip elements or reverse the sequence.

### Example:
```python
print(nums[::2])   # Output: [0, 2, 4, 6, 8] (Every second element)
print(nums[::-1])  # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (Reversed sequence)
```

---

## 4. **Negative Indices in Slicing**
Negative indices allow you to slice from the end of the sequence.

### Example:
```python
print(nums[-5:])      # Output: [5, 6, 7, 8, 9]
print(nums[-7:-3])    # Output: [3, 4, 5, 6]
print(nums[::-2])     # Output: [9, 7, 5, 3, 1]
```

---

## 5. **Slicing Strings**
Strings, being immutable sequences, support slicing similarly to lists.

### Example:
```python
text = "Hello, World!"
print(text[7:12])   # Output: 'World'
print(text[::-1])   # Output: '!dlroW ,olleH'
```

---

## 6. **Slicing Tuples**
Tuples, like strings, are immutable sequences and support slicing.

### Example:
```python
tuple_data = (10, 20, 30, 40, 50)
print(tuple_data[1:4])  # Output: (20, 30, 40)
```

---

## 7. **Slicing Nested Sequences**
Slicing can also be applied to nested sequences.

### Example:
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Extracting a sublist
print(matrix[1][:2])  # Output: [4, 5]
```

---

## 8. **Copying Sequences with Slicing**
Slicing with `[:]` creates a shallow copy of the sequence.

### Example:
```python
original = [1, 2, 3]
copied = original[:]

copied[0] = 10
print(original)  # Output: [1, 2, 3] (Unchanged)
print(copied)    # Output: [10, 2, 3]
```

---

## 9. **Edge Cases and Tips**

### 9.1 Index Out of Range:
Slicing handles out-of-range indices gracefully.
```python
nums = [1, 2, 3]
print(nums[1:10])  # Output: [2, 3]
```

### 9.2 Step Size of Zero:
Using a step size of zero raises a `ValueError`.
```python
# nums[::0]  # Raises ValueError: slice step cannot be zero
```

---

## 10. **Performance Considerations**
Slicing is efficient because it creates a new view of the data, without modifying the original sequence.

---

## 11. **Best Practices**
1. **Use Defaults Where Possible:**
   - Simplify slicing by omitting unnecessary `start`, `stop`, or `step` values.

2. **Use Negative Indices for Clarity:**
   - Negative indices make it easier to reference elements relative to the end of the sequence.

3. **Avoid Excessive Nesting:**
   - Keep slicing operations simple to improve code readability.

---

## 12. **Conclusion**
Slicing is a fundamental feature in Python that enhances the ability to work with sequences. By mastering slicing techniques, you can efficiently manipulate lists, strings, and other sequence types while writing clean, Pythonic code.

<a id='custom'></a>
# Custom Sequences in Python

In Python, you can create custom sequence types by implementing special methods that define how the sequence behaves. These sequences can emulate built-in types like lists or tuples or introduce entirely new behavior. Custom sequences are useful when you need specific functionality beyond what the built-in types offer.

---

## 1. **What Are Custom Sequences?**
- Custom sequences are user-defined classes that behave like built-in sequence types.
- They can be mutable or immutable.
- You can define specific behaviors such as indexing, slicing, iteration, and length calculation.

### Types of Sequences:
1. **Immutable Sequences:** Behave like strings or tuples.
2. **Mutable Sequences:** Behave like lists or bytearrays.

---

## 2. **Key Methods for Sequence Implementation**
To create a custom sequence, you need to define specific dunder methods:

| Method                | Purpose                                                                 |
|-----------------------|-------------------------------------------------------------------------|
| `__getitem__(self, index)` | Retrieve an element by index or handle slicing.                          |
| `__setitem__(self, index, value)` | Assign a value to a specific index (for mutable sequences).           |
| `__delitem__(self, index)` | Delete an item at a specific index (for mutable sequences).              |
| `__len__(self)`       | Return the number of elements in the sequence.                          |
| `__iter__(self)`      | Return an iterator for the sequence.                                    |
| `__contains__(self, item)` | Check if an item exists in the sequence (used for `in` and `not in`).     |
| `__reversed__(self)`  | Return a reversed version of the sequence.                              |
| `__add__(self, other)` | Define behavior for concatenation using `+`.                             |
| `__mul__(self, n)`    | Define behavior for repetition using `*`.                               |

---

## 3. **Implementing a Custom Sequence**

### 3.1 Immutable Custom Sequence
Here’s an example of a custom immutable sequence that behaves like a tuple:

#### Example:
```python
class ImmutableSequence:
    def __init__(self, data):
        self._data = tuple(data)  # Store data as a tuple

    def __getitem__(self, index):
        return self._data[index]

    def __len__(self):
        return len(self._data)

    def __contains__(self, item):
        return item in self._data

    def __repr__(self):
        return f"ImmutableSequence({self._data})"

# Usage
seq = ImmutableSequence([1, 2, 3, 4])
print(seq[1])         # Output: 2
print(len(seq))       # Output: 4
print(3 in seq)       # Output: True
print(seq)            # Output: ImmutableSequence((1, 2, 3, 4))
```

### 3.2 Mutable Custom Sequence
Here’s an example of a custom mutable sequence that behaves like a list:

#### Example:
```python
class MutableSequence:
    def __init__(self, data):
        self._data = list(data)  # Store data as a list

    def __getitem__(self, index):
        return self._data[index]

    def __setitem__(self, index, value):
        self._data[index] = value

    def __delitem__(self, index):
        del self._data[index]

    def __len__(self):
        return len(self._data)

    def append(self, value):
        self._data.append(value)

    def __repr__(self):
        return f"MutableSequence({self._data})"

# Usage
seq = MutableSequence([1, 2, 3])
seq[0] = 10
print(seq)            # Output: MutableSequence([10, 2, 3])
seq.append(4)
print(seq)            # Output: MutableSequence([10, 2, 3, 4])
del seq[1]
print(seq)            # Output: MutableSequence([10, 3, 4])
```

---

## 4. **Advanced Sequence Features**

### 4.1 Slicing Support
To handle slicing, you need to check whether the `index` is a slice object inside `__getitem__` and `__setitem__`.

#### Example:
```python
class SliceableSequence:
    def __init__(self, data):
        self._data = list(data)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return self._data[index.start:index.stop:index.step]
        return self._data[index]

    def __repr__(self):
        return f"SliceableSequence({self._data})"

# Usage
seq = SliceableSequence([1, 2, 3, 4, 5])
print(seq[1:4])       # Output: [2, 3, 4]
print(seq[:3])        # Output: [1, 2, 3]
```

### 4.2 Custom Iteration
Override `__iter__` to define how the sequence is iterated.

#### Example:
```python
class CustomIterableSequence:
    def __init__(self, data):
        self._data = data

    def __iter__(self):
        return (x * 2 for x in self._data)

# Usage
seq = CustomIterableSequence([1, 2, 3])
for item in seq:
    print(item)       # Output: 2, 4, 6
```

---

## 5. **Best Practices for Custom Sequences**
1. **Use Composition:**
   - Internally use a standard sequence type (e.g., list or tuple) to handle data.

2. **Follow Sequence Protocols:**
   - Implement as many methods as possible to maintain consistency with Python’s sequence types.

3. **Keep It Pythonic:**
   - Use meaningful names and follow Python’s conventions.

4. **Document Behavior Clearly:**
   - Specify whether the sequence is mutable or immutable.

---

## 6. **Use Cases for Custom Sequences**
- **Data Wrapping:** Encapsulating and controlling access to data.
- **Custom Behavior:** Adding domain-specific behavior, such as validation or transformations.
- **Performance Optimization:** Tailoring sequences for specific performance needs.

---

## 7. **Conclusion**
Creating custom sequences in Python gives you the flexibility to design data structures that fit your specific requirements. By implementing the sequence protocol methods, you can create objects that seamlessly integrate into Python’s ecosystem, making your code more powerful and expressive.

<a id='in-place'></a>
# In-Place Concatenation and Repetition in Python

In Python, in-place operations provide a way to modify mutable sequences like lists directly, without creating new objects. This includes in-place concatenation and repetition, commonly achieved using `+=` and `*=` operators, respectively.

---

## 1. **What is In-Place Concatenation?**
In-place concatenation modifies a sequence by appending elements from another sequence. This operation is performed using the `+=` operator for mutable sequences like lists.

### Example:
```python
# In-place concatenation for a list
nums = [1, 2, 3]
nums += [4, 5]
print(nums)  # Output: [1, 2, 3, 4, 5]
```

---

## 2. **What is In-Place Repetition?**
In-place repetition duplicates the elements of a sequence multiple times. This operation is performed using the `*=` operator for mutable sequences.

### Example:
```python
# In-place repetition for a list
nums = [1, 2, 3]
nums *= 2
print(nums)  # Output: [1, 2, 3, 1, 2, 3]
```

---

## 3. **Behavior of In-Place Operations with Mutable and Immutable Sequences**

### 3.1 Mutable Sequences (e.g., Lists)
In-place concatenation and repetition modify the original object directly.

#### Example:
```python
nums = [1, 2, 3]
print(id(nums))  # Original ID
nums += [4]
print(nums)      # Output: [1, 2, 3, 4]
print(id(nums))  # Same ID as before
```

### 3.2 Immutable Sequences (e.g., Tuples, Strings)
For immutable sequences, in-place operations create a new object instead of modifying the original.

#### Example:
```python
tuple_data = (1, 2, 3)
print(id(tuple_data))  # Original ID
tuple_data += (4,)
print(tuple_data)      # Output: (1, 2, 3, 4)
print(id(tuple_data))  # Different ID (new object)
```

---

## 4. **Key Differences Between `+=` and `+`**

| Operation | Mutable Sequences                  | Immutable Sequences             |
|-----------|------------------------------------|----------------------------------|
| `+=`      | Modifies the original object       | Creates a new object            |
| `+`       | Creates a new object              | Creates a new object            |

### Example:
```python
# Using += with lists
nums = [1, 2, 3]
nums += [4]
print(nums)  # Output: [1, 2, 3, 4]

# Using + with lists
nums = [1, 2, 3]
new_nums = nums + [4]
print(nums)      # Output: [1, 2, 3]
print(new_nums)  # Output: [1, 2, 3, 4]
```

---

## 5. **Best Practices for In-Place Operations**

1. **Use In-Place Operations for Mutable Sequences:**
   - In-place operations are efficient because they avoid creating new objects.
   - Example:
     ```python
     nums = [1, 2, 3]
     nums += [4, 5]
     ```

2. **Avoid In-Place Operations for Immutable Sequences:**
   - Using in-place operators on immutable sequences results in new object creation, which can be less efficient.
   - Example:
     ```python
     string = "hello"
     string += " world"
     print(string)  # Output: 'hello world'
     ```

3. **Be Aware of Side Effects:**
   - In-place operations can modify the original object, which may lead to unintended consequences if the object is shared.
   - Example:
     ```python
     nums = [1, 2, 3]
     alias = nums
     nums += [4]
     print(alias)  # Output: [1, 2, 3, 4] (alias is also updated)
     ```

4. **Use Explicit Copying When Needed:**
   - Create a copy of the sequence before performing in-place operations if you want to avoid modifying the original.
   - Example:
     ```python
     nums = [1, 2, 3]
     copied_nums = nums[:]
     copied_nums += [4]
     print(nums)        # Output: [1, 2, 3]
     print(copied_nums) # Output: [1, 2, 3, 4]
     ```

---

## 6. **Common Use Cases**

### 6.1 Concatenating and Repeating Lists
```python
# Combine multiple lists
nums = [1, 2]
nums += [3, 4]

# Repeat elements
nums *= 2
print(nums)  # Output: [1, 2, 3, 4, 1, 2, 3, 4]
```

### 6.2 Updating Shared Data Structures
```python
# Shared list
shared_list = [1, 2, 3]
shared_list += [4]
print(shared_list)  # Output: [1, 2, 3, 4]
```

---

## 7. **Conclusion**
In-place concatenation and repetition are efficient ways to modify mutable sequences. However, understanding their behavior with both mutable and immutable sequences is essential to avoid unintended consequences. Use them judiciously in scenarios where performance and clarity are priorities.
<a id='assignments'></a>
# Assignments in Mutable Sequences

Mutable sequences in Python, such as lists and bytearrays, allow modification of their elements directly. Understanding how assignments work in mutable sequences is critical for efficient and bug-free programming.

---

## 1. **What Are Mutable Sequences?**
- **Definition:** Sequences that can be modified in place without creating a new object.
- **Examples:** Lists, bytearrays, and certain user-defined sequence types.

---

## 2. **Types of Assignments in Mutable Sequences**

### 2.1 Single Element Assignment
You can modify a single element of a mutable sequence by specifying its index.

#### Example:
```python
nums = [1, 2, 3, 4]
nums[1] = 20
print(nums)  # Output: [1, 20, 3, 4]
```

### 2.2 Slicing Assignment
Slicing allows you to replace multiple elements at once. The replacement sequence must match the number of elements being replaced unless you expand or contract the slice.

#### Example (Direct Replacement):
```python
nums = [1, 2, 3, 4]
nums[1:3] = [20, 30]
print(nums)  # Output: [1, 20, 30, 4]
```

#### Example (Expanding):
```python
nums = [1, 2, 3, 4]
nums[1:3] = [20, 30, 40, 50]
print(nums)  # Output: [1, 20, 30, 40, 50, 4]
```

#### Example (Contracting):
```python
nums = [1, 2, 3, 4]
nums[1:3] = [20]
print(nums)  # Output: [1, 20, 4]
```

### 2.3 Assignment with Step
When assigning to a slice with a step, the size of the replacement sequence must match the size of the target slice.

#### Example:
```python
nums = [1, 2, 3, 4, 5]
nums[::2] = [10, 20, 30]
print(nums)  # Output: [10, 2, 20, 4, 30]
```

#### Invalid Example:
```python
nums = [1, 2, 3, 4, 5]
# nums[::2] = [10, 20]  # Raises ValueError: attempt to assign sequence of size 2 to extended slice of size 3
```

---

## 3. **Deleting Elements in Mutable Sequences**

### 3.1 Single Element Deletion
The `del` keyword removes an element at a specific index.

#### Example:
```python
nums = [1, 2, 3, 4]
del nums[1]
print(nums)  # Output: [1, 3, 4]
```

### 3.2 Slicing Deletion
The `del` keyword can also delete multiple elements via slicing.

#### Example:
```python
nums = [1, 2, 3, 4]
del nums[1:3]
print(nums)  # Output: [1, 4]
```

---

## 4. **Assignments and References**
When assigning one mutable sequence to another, both variables point to the same underlying data, meaning changes to one will affect the other.

### Example:
```python
nums = [1, 2, 3]
alias = nums
alias[0] = 10
print(nums)   # Output: [10, 2, 3]
print(alias)  # Output: [10, 2, 3]
```

To create a separate copy, use slicing or the `copy` module.

#### Example (Creating a Copy):
```python
nums = [1, 2, 3]
copy_nums = nums[:]
copy_nums[0] = 10
print(nums)       # Output: [1, 2, 3]
print(copy_nums)  # Output: [10, 2, 3]
```

---

## 5. **Common Use Cases**

### 5.1 Updating a List
```python
nums = [1, 2, 3]
nums[1] = 100
print(nums)  # Output: [1, 100, 3]
```

### 5.2 Inserting Elements with Slicing
```python
nums = [1, 2, 3]
nums[1:1] = [10, 20]
print(nums)  # Output: [1, 10, 20, 2, 3]
```

### 5.3 Deleting Multiple Elements
```python
nums = [1, 2, 3, 4, 5]
del nums[1:4]
print(nums)  # Output: [1, 5]
```

---

## 6. **Best Practices**
1. **Use Slicing for Bulk Modifications:**
   - Slicing is efficient and makes the code more readable for bulk updates.

2. **Be Careful with References:**
   - When assigning one mutable sequence to another, remember that both will reference the same object.

3. **Use Copies When Needed:**
   - Use slicing or the `copy` module to avoid unintentional changes to the original sequence.

4. **Validate Slice Sizes:**
   - Ensure replacement sequences match the size of the target slice when using a step.

---

## 7. **Conclusion**
Assignments in mutable sequences provide powerful mechanisms for modifying data in place. By mastering these techniques and understanding their implications, you can work efficiently with Python's mutable data structures while avoiding common pitfalls.

<a id='sorting'></a>
# Sorting Sequences in Python

Sorting sequences is a fundamental operation in Python, and it is supported natively for most sequence types like lists and tuples. Python provides several ways to sort sequences, both in-place and by creating new sorted sequences, offering a high degree of flexibility.

---

## 1. **Why Sort Sequences?**
Sorting organizes data in a sequence based on specific criteria, making it easier to:
- Search for elements.
- Analyze or visualize data.
- Ensure consistent order for further processing.

---

## 2. **Built-in Sorting Methods**

### 2.1 `sorted()`
The `sorted()` function returns a new sorted sequence without modifying the original.

#### Syntax:
```python
sorted(iterable, key=None, reverse=False)
```

#### Parameters:
- **`iterable`**: The sequence to be sorted.
- **`key`**: A function defining the sorting criteria (optional).
- **`reverse`**: A boolean flag to sort in descending order (default is `False`).

#### Example:
```python
nums = [3, 1, 4, 1, 5]
sorted_nums = sorted(nums)
print(sorted_nums)  # Output: [1, 1, 3, 4, 5]
print(nums)         # Output: [3, 1, 4, 1, 5] (original unchanged)
```

#### Sorting in Reverse Order:
```python
sorted_nums_desc = sorted(nums, reverse=True)
print(sorted_nums_desc)  # Output: [5, 4, 3, 1, 1]
```

### 2.2 `list.sort()`
The `list.sort()` method sorts the list in place, modifying the original list.

#### Syntax:
```python
list.sort(key=None, reverse=False)
```

#### Example:
```python
nums = [3, 1, 4, 1, 5]
nums.sort()
print(nums)  # Output: [1, 1, 3, 4, 5]
```

---

## 3. **Sorting with Keys**
The `key` parameter allows customization of sorting criteria by providing a function to extract a comparison key from each element.

### Example: Sorting by Absolute Value
```python
nums = [-4, 1, -3, 2]
sorted_nums = sorted(nums, key=abs)
print(sorted_nums)  # Output: [1, 2, -3, -4]
```

### Example: Sorting Strings by Length
```python
words = ["apple", "bat", "banana"]
sorted_words = sorted(words, key=len)
print(sorted_words)  # Output: ['bat', 'apple', 'banana']
```

---

## 4. **Sorting with Custom Functions**

### Example: Sorting by Second Element in Tuples
```python
pairs = [(1, 3), (2, 2), (4, 1)]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)  # Output: [(4, 1), (2, 2), (1, 3)]
```

---

## 5. **Sorting Strings**
Strings can be sorted alphabetically using `sorted()`.

### Example:
```python
text = "python"
sorted_chars = sorted(text)
print(sorted_chars)  # Output: ['h', 'n', 'o', 'p', 't', 'y']
```

### Example: Joining Sorted Characters
```python
sorted_text = ''.join(sorted(text))
print(sorted_text)  # Output: 'hnopty'
```

---

## 6. **Stability in Sorting**
Python's sorting algorithms are **stable**, meaning that the relative order of equal elements is preserved.

### Example:
```python
students = [("Alice", 25), ("Bob", 25), ("Charlie", 20)]
sorted_students = sorted(students, key=lambda x: x[1])
print(sorted_students)  # Output: [('Charlie', 20), ('Alice', 25), ('Bob', 25)]
```

---

## 7. **Reverse Sorting**
You can reverse the sorting order by setting `reverse=True` in both `sorted()` and `list.sort()`.

### Example:
```python
nums = [3, 1, 4, 1, 5]
nums.sort(reverse=True)
print(nums)  # Output: [5, 4, 3, 1, 1]
```

---

## 8. **Performance of Sorting**
Python's sorting algorithms use **Timsort**, which has a time complexity of:
- **O(n log n)** in the worst case.
- **O(n)** for nearly sorted data.

---

## 9. **Sorting Other Sequence Types**

### Sorting Tuples:
Tuples are immutable, so `sorted()` must be used to return a new sorted list.
```python
nums = (3, 1, 4, 1, 5)
sorted_nums = sorted(nums)
print(sorted_nums)  # Output: [1, 1, 3, 4, 5]
```

### Sorting Nested Lists:
```python
matrix = [[3, 2], [1, 4], [5, 0]]
sorted_matrix = sorted(matrix, key=lambda x: x[1])
print(sorted_matrix)  # Output: [[5, 0], [3, 2], [1, 4]]
```

---

## 10. **Common Use Cases**
1. **Sorting Names Alphabetically:**
   ```python
   names = ["Zara", "Alice", "Bob"]
   print(sorted(names))  # Output: ['Alice', 'Bob', 'Zara']
   ```

2. **Sorting Dates:**
   ```python
   from datetime import date
   dates = [date(2023, 5, 1), date(2021, 8, 15), date(2022, 12, 25)]
   print(sorted(dates))  # Output: [datetime.date(2021, 8, 15), datetime.date(2022, 12, 25), datetime.date(2023, 5, 1)]
   ```

3. **Sorting Dictionaries by Value:**
   ```python
   scores = {"Alice": 90, "Bob": 85, "Charlie": 95}
   sorted_scores = sorted(scores.items(), key=lambda x: x[1])
   print(sorted_scores)  # Output: [('Bob', 85), ('Alice', 90), ('Charlie', 95)]
   ```

---

## 11. **Best Practices**
1. **Use `sorted()` for Immutable Data:**
   - Prefer `sorted()` when working with immutable sequences like tuples.

2. **Use `list.sort()` for In-Place Modifications:**
   - Use `list.sort()` when you need to modify the list directly and save memory.

3. **Leverage the `key` Parameter:**
   - Use custom sorting logic with the `key` parameter for advanced use cases.

4. **Avoid Sorting Large Sequences Repeatedly:**
   - Cache sorted results if the same sequence needs to be sorted multiple times.

---

## 12. **Conclusion**
Sorting sequences is an essential operation for organizing and analyzing data in Python. By understanding the capabilities of `sorted()` and `list.sort()`, as well as leveraging custom sorting with the `key` parameter, you can handle a wide range of sorting tasks effectively and efficiently.

<a id='list-comprehension'></a>
# List Comprehension in Python

List comprehension is a concise and Pythonic way to create lists. It allows for generating new lists by applying an expression to each element in an iterable, optionally filtering elements using conditions.

---

## 1. **What is List Comprehension?**
- A syntax for creating lists based on existing iterables.
- Combines a `for` loop and optional `if` condition into a single line.
- More concise and readable compared to traditional loops.

### Syntax:
```python
[expression for item in iterable if condition]
```

---

## 2. **Examples of List Comprehension**

### 2.1 Basic List Comprehension
Create a list of squares for numbers from 1 to 5.
```python
squares = [x**2 for x in range(1, 6)]
print(squares)  # Output: [1, 4, 9, 16, 25]
```

### 2.2 Using a Condition
Filter even numbers from a range.
```python
even_numbers = [x for x in range(10) if x % 2 == 0]
print(even_numbers)  # Output: [0, 2, 4, 6, 8]
```

### 2.3 Nested Loops in List Comprehension
Generate all pairs (i, j) where `i` is from 1 to 3 and `j` is from 4 to 6.
```python
pairs = [(i, j) for i in range(1, 4) for j in range(4, 7)]
print(pairs)  # Output: [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]
```

### 2.4 Transforming Strings
Convert a list of strings to uppercase.
```python
words = ["hello", "world"]
uppercase_words = [word.upper() for word in words]
print(uppercase_words)  # Output: ['HELLO', 'WORLD']
```

---

## 3. **Advanced List Comprehension**

### 3.1 Nested List Comprehensions
Flatten a 2D list into a 1D list.
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
print(flattened)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 3.2 Conditional Expressions
Replace negative numbers with zero.
```python
nums = [-1, 2, -3, 4]
processed = [x if x > 0 else 0 for x in nums]
print(processed)  # Output: [0, 2, 0, 4]
```

### 3.3 Dictionary and Set Comprehensions
List comprehension concepts extend to dictionaries and sets:

#### Dictionary Comprehension:
```python
squares = {x: x**2 for x in range(1, 6)}
print(squares)  # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

#### Set Comprehension:
```python
even_numbers = {x for x in range(10) if x % 2 == 0}
print(even_numbers)  # Output: {0, 2, 4, 6, 8}
```

---

## 4. **Advantages of List Comprehension**
1. **Concise and Readable:**
   - Combines looping and filtering into a single line.

2. **Improved Performance:**
   - Faster than traditional loops due to optimized bytecode.

3. **Pythonic:**
   - Encourages clean and elegant code.

---

## 5. **Limitations of List Comprehension**
1. **Readability for Complex Logic:**
   - Complex list comprehensions can become hard to read.
   - Example (hard to interpret):
     ```python
     result = [x if x % 2 == 0 else x**2 for x in range(10) if x % 3 == 0]
     ```

2. **Memory Usage:**
   - Creates the entire list in memory, which may be inefficient for large datasets.

---

## 6. **Alternatives to List Comprehension**

### Using Loops:
```python
nums = []
for x in range(1, 6):
    nums.append(x**2)
print(nums)  # Output: [1, 4, 9, 16, 25]
```

### Using Generator Expressions:
For memory-efficient iteration, use a generator:
```python
gen = (x**2 for x in range(1, 6))
for num in gen:
    print(num)
```

---

## 7. **Common Use Cases**
1. **Filtering Data:** Extract elements that meet a condition.
2. **Transforming Data:** Apply a function to each element.
3. **Combining Iterables:** Generate combinations or permutations.
4. **Flattening Nested Structures:** Reduce multi-dimensional data to a single dimension.

---

## 8. **Best Practices**
1. **Keep It Simple:**
   - Use list comprehension for simple operations.
   - Avoid deeply nested comprehensions.

2. **Comment Complex Logic:**
   - Add comments for list comprehensions with conditions or nested loops.

3. **Consider Alternatives:**
   - Use loops or generator expressions for readability or memory efficiency.

---

## 9. **Conclusion**
List comprehensions are a powerful feature of Python, enabling concise, efficient, and Pythonic code. While they are ideal for simple operations, understanding their limitations and when to use alternatives ensures your code remains clean and maintainable.
