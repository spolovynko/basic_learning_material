- [OBJECT AND CLASSES](#obejct-classes)
- [CLASS ATTRIBUTES](#attributes)
- [CALLABLE CLASS ATTRIBUTES](#callable)
- [CLASSES ARE CALLABLE](#classes-callable)
- [DATA ATTRIBUTES](#data-attributes)
- [FUNCTION-ATTRIBUTES](#function-attributes)
- [INTIALIZING CLASS INSTANCES](#initializing-instances)
- [CREATING ATTRIBUTES IN RUN-TIME](#run-time)
- [PROPERITES](#properties)
- [PROPERITY DECORATORS](#property-decorators)
- [READ-ONLY AND COMPUTED PROPERTIES](#read-only)
- [DELETING PROPERTIES](#deleting)
- [CLASS AND STATIC METHODS](#class-static)
- [CLASS BODY SCOPE](#class-body)
  
<a id='obejct-classes'></a>
# Objects and Classes in Python

Python is an object-oriented programming (OOP) language, which means it provides support for encapsulating data and functionality into objects and classes. Understanding objects and classes is fundamental for designing modular, reusable, and efficient code.

---

## 1. **What is a Class?**

A **class** is a blueprint for creating objects. It defines the properties (attributes) and behaviors (methods) that the objects created from the class will have.

### Syntax:
```python
class ClassName:
    # Class attributes
    # Methods
```

### Example:
```python
class Dog:
    # Class attribute
    species = "Canis familiaris"

    # Initializer (Constructor)
    def __init__(self, name, age):
        self.name = name  # Instance attribute
        self.age = age    # Instance attribute

    # Instance method
    def bark(self):
        return f"{self.name} says Woof!"

# Creating an object
dog = Dog("Buddy", 5)
print(dog.name)       # Output: Buddy
print(dog.bark())     # Output: Buddy says Woof!
```

---

## 2. **What is an Object?**

An **object** is an instance of a class. It represents a specific entity with the attributes and methods defined in the class.

### Characteristics:
1. **Encapsulation:** Bundles data (attributes) and methods together.
2. **Instance-Specific Data:** Each object has its own set of data for instance attributes.

---

## 3. **Instance Attributes vs Class Attributes**

### Instance Attributes:
- Defined in the constructor (`__init__`) or other methods.
- Specific to an object.

### Class Attributes:
- Shared by all instances of the class.
- Defined directly in the class body.

#### Example:
```python
class Car:
    # Class attribute
    wheels = 4

    def __init__(self, make, model):
        self.make = make  # Instance attribute
        self.model = model  # Instance attribute

car1 = Car("Toyota", "Corolla")
car2 = Car("Honda", "Civic")

print(car1.wheels)  # Output: 4
print(car1.make)    # Output: Toyota
print(car2.wheels)  # Output: 4
```

---

## 4. **Methods in a Class**

### Types of Methods:

#### 4.1 **Instance Methods:**
Operate on instance attributes and take `self` as the first parameter.

#### Example:
```python
class Person:
    def __init__(self, name):
        self.name = name

    def greet(self):
        return f"Hello, {self.name}!"

person = Person("Alice")
print(person.greet())  # Output: Hello, Alice!
```

#### 4.2 **Class Methods:**
Operate on class attributes and take `cls` as the first parameter.

#### Example:
```python
class Animal:
    species = "Animal"

    @classmethod
    def set_species(cls, new_species):
        cls.species = new_species

Animal.set_species("Mammal")
print(Animal.species)  # Output: Mammal
```

#### 4.3 **Static Methods:**
Do not operate on class or instance attributes. They take no `self` or `cls` parameter.

#### Example:
```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y

print(Math.add(3, 5))  # Output: 8
```

---

## 5. **Encapsulation**

Encapsulation is the bundling of data (attributes) and methods into a single unit (class) while restricting direct access to some of the components.

### Access Modifiers in Python:
1. **Public Attributes:**
   - Accessible from anywhere.
   - Example: `self.name`

2. **Protected Attributes:**
   - Prefixed with a single underscore (`_`).
   - Intended for internal use but not strictly private.

3. **Private Attributes:**
   - Prefixed with double underscores (`__`).
   - Name mangling makes them harder to access from outside the class.

#### Example:
```python
class Example:
    def __init__(self):
        self.public = "Public"
        self._protected = "Protected"
        self.__private = "Private"

obj = Example()
print(obj.public)       # Output: Public
print(obj._protected)   # Output: Protected
# print(obj.__private)  # AttributeError
```

---

## 6. **Inheritance**

Inheritance allows a class (child) to inherit attributes and methods from another class (parent).

### Example:
```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def start(self):
        return f"{self.brand} is starting."

class Car(Vehicle):
    def drive(self):
        return f"{self.brand} is driving."

car = Car("Toyota")
print(car.start())  # Output: Toyota is starting.
print(car.drive())  # Output: Toyota is driving.
```

---

## 7. **Polymorphism**

Polymorphism allows methods to be defined in a parent class but overridden in child classes.

### Example:
```python
class Shape:
    def area(self):
        return 0

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

shape = Shape()
circle = Circle(5)
print(shape.area())   # Output: 0
print(circle.area())  # Output: 78.5
```

---

## 8. **Special Methods**

Special (or dunder) methods start and end with double underscores (`__`) and allow customization of built-in Python operations.

### Example:
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __repr__(self):
        return f"Point({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
print(p1 + p2)  # Output: Point(4, 6)
```

---

## 9. **Best Practices for OOP**

1. **Use Meaningful Class and Method Names:**
   - Names should clearly convey purpose.

2. **Follow DRY (Don't Repeat Yourself):**
   - Avoid duplicating code by using inheritance and methods.

3. **Encapsulate Data:**
   - Use access modifiers to protect data.

4. **Keep Classes Small and Focused:**
   - Each class should represent a single responsibility.

5. **Use Composition Over Inheritance When Possible:**
   - Prefer combining multiple small classes rather than creating deep inheritance hierarchies.

---

## 10. **Conclusion**

Objects and classes form the backbone of Python's object-oriented programming paradigm. By leveraging features like inheritance, polymorphism, and encapsulation, you can design flexible, modular, and reusable code. Understanding these concepts is key to mastering Python and writing efficient, maintainable applications.

<a id='attributes'></a>
# Class Attributes in Python

Class attributes are variables defined directly within a class and shared across all instances of that class. Unlike instance attributes, which are unique to each object, class attributes provide a shared state or behavior among all instances.

---

## 1. **What are Class Attributes?**

### Key Characteristics:
1. **Shared Across Instances:** All instances of the class share the same class attribute.
2. **Defined Outside Methods:** Declared within the class body but outside any methods.
3. **Accessed via Class or Instance:** Can be accessed using either the class name or an instance of the class.

### Example:
```python
class Car:
    # Class attribute
    wheels = 4

    def __init__(self, make, model):
        self.make = make  # Instance attribute
        self.model = model  # Instance attribute

# Accessing class attributes
print(Car.wheels)  # Output: 4

car1 = Car("Toyota", "Corolla")
car2 = Car("Honda", "Civic")

print(car1.wheels)  # Output: 4
print(car2.wheels)  # Output: 4
```

---

## 2. **Difference Between Class and Instance Attributes**

| **Feature**          | **Class Attributes**                       | **Instance Attributes**                |
|----------------------|--------------------------------------------|----------------------------------------|
| **Scope**            | Shared across all instances                | Specific to each instance              |
| **Defined**          | Outside methods in the class body          | Inside methods (usually `__init__`)    |
| **Access**           | Can be accessed via class or instance      | Accessed only via the instance         |
| **Modification**     | Modifying via instance creates new instance-specific value | Modifies the shared value when changed via class |

#### Example:
```python
class Example:
    class_attr = "Shared"

    def __init__(self, value):
        self.instance_attr = value

obj1 = Example("Instance 1")
obj2 = Example("Instance 2")

# Class attribute
print(Example.class_attr)  # Output: Shared
print(obj1.class_attr)     # Output: Shared

# Instance attribute
print(obj1.instance_attr)  # Output: Instance 1
print(obj2.instance_attr)  # Output: Instance 2
```

---

## 3. **Accessing Class Attributes**

Class attributes can be accessed via the class name or an instance. 

### Example:
```python
class Animal:
    species = "Mammal"

# Accessing via class name
print(Animal.species)  # Output: Mammal

# Accessing via instance
dog = Animal()
print(dog.species)  # Output: Mammal
```

---

## 4. **Modifying Class Attributes**

### 4.1 Modifying via Class Name:
Changes the value for all instances.
```python
class Bird:
    can_fly = True

bird1 = Bird()
bird2 = Bird()

# Modify class attribute via class
Bird.can_fly = False

print(bird1.can_fly)  # Output: False
print(bird2.can_fly)  # Output: False
```

### 4.2 Modifying via Instance:
Creates an instance-specific attribute, leaving the class attribute unchanged.
```python
class Fish:
    can_swim = True

fish1 = Fish()
fish2 = Fish()

# Modify class attribute via instance
fish1.can_swim = False

print(fish1.can_swim)  # Output: False (instance-specific value)
print(fish2.can_swim)  # Output: True (class value remains unchanged)
```

---

## 5. **Use Cases for Class Attributes**

### 5.1 Shared Constants:
Useful for defining shared constants across all instances.
```python
class Circle:
    PI = 3.14  # Class attribute

    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return Circle.PI * self.radius ** 2

circle = Circle(5)
print(circle.area())  # Output: 78.5
```

### 5.2 Tracking Shared State:
Class attributes can maintain shared state among instances.
```python
class Counter:
    count = 0  # Shared state

    def __init__(self):
        Counter.count += 1

c1 = Counter()
c2 = Counter()
print(Counter.count)  # Output: 2
```

---

## 6. **Best Practices**

1. **Use for Shared Data:**
   - Define attributes that are the same for all instances, such as constants or shared counters.

2. **Avoid Overwriting Unintentionally:**
   - Be cautious when modifying class attributes via instances to avoid unexpected behavior.

3. **Access via Class Name for Clarity:**
   - Prefer accessing class attributes using the class name for better readability.

4. **Combine with Class Methods:**
   - Use class methods (`@classmethod`) to manipulate class attributes.

---

## 7. **Conclusion**

Class attributes are a powerful feature in Python for defining shared data or behavior across all instances of a class. By understanding how they differ from instance attributes and following best practices, you can use class attributes effectively to write clear and efficient object-oriented code.

<a id='callable'></a>
# Callable Class Attributes in Python

Callable class attributes in Python are attributes of a class that can be invoked like functions. These attributes are usually defined as methods or callable objects, providing additional functionality when accessed.

---

## 1. **What are Callable Class Attributes?**

### Key Characteristics:
1. **Invocable:** They can be called like regular functions.
2. **Defined as Functions or Callable Objects:** Typically implemented using methods or callable classes.
3. **Class-Level Scope:** Shared across all instances of the class, if defined as class attributes.

### Example:
```python
class Calculator:
    @staticmethod
    def add(a, b):
        return a + b

    @classmethod
    def multiply(cls, a, b):
        return a * b

# Accessing callable class attributes
print(Calculator.add(5, 3))      # Output: 8
print(Calculator.multiply(5, 3)) # Output: 15
```

---

## 2. **Callable vs Non-Callable Class Attributes**

| **Feature**                | **Callable Attributes**          | **Non-Callable Attributes**          |
|----------------------------|-----------------------------------|---------------------------------------|
| **Behavior**               | Can be invoked like a function   | Stores data or state                 |
| **Example**                | `@staticmethod`, `@classmethod`  | Constants, shared variables           |
| **Usage**                  | Performs actions or computations | Shares state across instances         |

---

## 3. **Defining Callable Class Attributes**

### 3.1 Using Static Methods:
Static methods are callable class attributes that do not depend on class or instance state.
```python
class Utility:
    @staticmethod
    def greet(name):
        return f"Hello, {name}!"

print(Utility.greet("Alice"))  # Output: Hello, Alice!
```

### 3.2 Using Class Methods:
Class methods operate on class attributes and take `cls` as the first argument.
```python
class Counter:
    count = 0

    @classmethod
    def increment(cls):
        cls.count += 1
        return cls.count

print(Counter.increment())  # Output: 1
print(Counter.increment())  # Output: 2
```

### 3.3 Using Callable Objects:
You can define a callable object by implementing the `__call__` method in a class.
```python
class Greeter:
    def __call__(self, name):
        return f"Welcome, {name}!"

# Create a callable object
greet = Greeter()
print(greet("Bob"))  # Output: Welcome, Bob!
```

---

## 4. **Combining Callable Attributes with Class Attributes**

Callable attributes often work with class-level data to provide functionality tied to shared state.

### Example:
```python
class BankAccount:
    interest_rate = 0.05  # Class attribute

    @classmethod
    def calculate_interest(cls, principal):
        return principal * cls.interest_rate

print(BankAccount.calculate_interest(1000))  # Output: 50.0
```

---

## 5. **Use Cases for Callable Class Attributes**

1. **Utility Functions:**
   - Implement commonly used functions within a class.
   ```python
   class Math:
       @staticmethod
       def square(x):
           return x * x

   print(Math.square(4))  # Output: 16
   ```

2. **Configuration and Initialization:**
   - Use class methods to initialize or configure shared data.
   ```python
   class Config:
       settings = {}

       @classmethod
       def set(cls, key, value):
           cls.settings[key] = value

   Config.set("debug", True)
   print(Config.settings)  # Output: {'debug': True}
   ```

3. **Custom Behavior:**
   - Define callable objects for flexible behavior.
   ```python
   class Logger:
       def __init__(self, prefix):
           self.prefix = prefix

       def __call__(self, message):
           print(f"{self.prefix}: {message}")

   log = Logger("INFO")
   log("System started")  # Output: INFO: System started
   ```

---

## 6. **Advantages of Callable Class Attributes**

1. **Encapsulation:**
   - Combine behavior and data in a single class.

2. **Modularity:**
   - Define reusable functionality within a logical scope.

3. **Flexibility:**
   - Support both static, class-level, and instance-specific behavior.

4. **Enhanced Readability:**
   - Makes the code more organized by grouping related operations.

---

## 7. **Best Practices**

1. **Use Descriptive Names:**
   - Name callable attributes clearly to reflect their purpose.

2. **Static vs Class Methods:**
   - Use static methods when no class or instance context is required.
   - Use class methods to work with class-level data.

3. **Leverage Callable Objects for Complex Behavior:**
   - Use callable objects for cases requiring more state or configuration.

4. **Keep It Simple:**
   - Avoid overcomplicating callable attributes unless necessary.

---

## 8. **Conclusion**

Callable class attributes in Python add significant flexibility and power to object-oriented design. By understanding and leveraging static methods, class methods, and callable objects, you can encapsulate complex behaviors within your classes while maintaining clear and modular code. They are an essential tool for Python developers working on scalable and maintainable applications.

<a id='classes-callable'></a>
# Classes Are Callables in Python

In Python, classes themselves are callable objects. When a class is called, it creates and returns a new instance of that class by invoking the class’s `__call__` method. This behavior is fundamental to Python's object-oriented programming (OOP) and enables the instantiation of objects in an intuitive and familiar way.

---

## 1. **What Does It Mean That Classes Are Callables?**

A class is callable in the sense that it behaves like a function when used with parentheses (`()`), and this invocation creates a new object (instance) of the class.

### Example:
```python
class Example:
    def __init__(self, value):
        self.value = value

# Calling the class to create an instance
instance = Example("Hello")
print(instance.value)  # Output: Hello
```

### Behind the Scenes:
When you call `Example("Hello")`, Python:
1. Allocates memory for the new object.
2. Invokes the `__init__` method to initialize the instance.
3. Returns the newly created instance.

---

## 2. **The `__call__` Method and Classes**

In Python, classes are callable because they implement the `__call__` method in their metaclass (`type` by default). This allows them to behave like functions.

### Example:
```python
class MyClass:
    def __init__(self, value):
        self.value = value

# Equivalent to:
# type(MyClass).__call__(MyClass, value="Hello")
obj = MyClass("Hello")
print(obj.value)  # Output: Hello
```

---

## 3. **Customizing the Callable Behavior of a Class**

You can make instances of a class callable by implementing the `__call__` method in the class.

### Example:
```python
class Adder:
    def __init__(self, base):
        self.base = base

    def __call__(self, value):
        return self.base + value

add_five = Adder(5)
print(add_five(10))  # Output: 15
```

### Explanation:
- The `__call__` method allows the instance `add_five` to be invoked like a function.
- This pattern is commonly used for functional programming and dynamic behavior.

---

## 4. **Combining Classes and Callables**

Classes being callable opens up powerful patterns in Python, such as factories, decorators, and stateful callables.

### Example: Factory Pattern
```python
class PersonFactory:
    def __call__(self, name, age):
        class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age

            def __repr__(self):
                return f"Person({self.name}, {self.age})"

        return Person(name, age)

factory = PersonFactory()
person = factory("Alice", 30)
print(person)  # Output: Person(Alice, 30)
```

---

## 5. **Why Classes Are Callables**

### Benefits:
1. **Intuitive Syntax:**
   - Allows class instantiation to look like function calls.
2. **Uniform Interface:**
   - Makes Python objects consistent, as many types (functions, classes, methods) are callable.
3. **Flexibility:**
   - Enables dynamic behavior by customizing the `__call__` method.

---

## 6. **Practical Use Cases**

### 6.1 Stateful Callables:
Preserve state between calls using the `__call__` method.
```python
class Counter:
    def __init__(self):
        self.count = 0

    def __call__(self):
        self.count += 1
        return self.count

counter = Counter()
print(counter())  # Output: 1
print(counter())  # Output: 2
```

### 6.2 Decorators:
Classes can act as decorators by implementing `__call__`.
```python
class Decorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("Before function call")
        result = self.func(*args, **kwargs)
        print("After function call")
        return result

@Decorator
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Output:
# Before function call
# Hello, Alice!
# After function call
```

### 6.3 Factories:
Create objects dynamically based on input.
```python
class ShapeFactory:
    def __call__(self, shape_type):
        if shape_type == "circle":
            return "Circle object created"
        elif shape_type == "square":
            return "Square object created"
        else:
            return "Unknown shape"

factory = ShapeFactory()
print(factory("circle"))  # Output: Circle object created
```

---

## 7. **Best Practices**

1. **Use `__call__` for Stateful Behavior:**
   - Implement `__call__` when you need to maintain state across calls.

2. **Keep Instantiation Clear:**
   - Avoid overcomplicating the instantiation process of classes.

3. **Use Callable Classes in Functional Programming:**
   - They work well as lightweight alternatives to functions when state retention is needed.

4. **Combine with Decorators:**
   - Callable classes can add dynamic behavior to functions or methods.

---

## 8. **Conclusion**

In Python, classes are inherently callable, providing a unified interface for creating objects. By implementing the `__call__` method, developers can extend this behavior to make instances callable, enabling dynamic and stateful operations. This flexibility enhances Python’s expressive power, making it suitable for a wide range of programming paradigms, from object-oriented to functional programming.
<a id='data-attributes'></a>
# Data Attributes in Python

Data attributes in Python are variables that belong to an object or a class and are used to store state or information about the object. They can be either instance attributes, unique to each object, or class attributes, shared among all instances of a class.

---

## 1. **What Are Data Attributes?**

### Key Characteristics:
1. **Defined Within a Class:**
   - Declared in a class but can vary between instances.
2. **Used to Store State:**
   - Contain data relevant to the specific object or class.
3. **Two Types:**
   - **Instance Attributes:** Belong to individual objects.
   - **Class Attributes:** Shared across all objects of the class.

---

## 2. **Types of Data Attributes**

### 2.1 Instance Attributes
- Defined in the constructor method `__init__` or dynamically added to an object.
- Unique to each instance.

#### Example:
```python
class Car:
    def __init__(self, make, model):
        self.make = make  # Instance attribute
        self.model = model  # Instance attribute

# Create two instances
car1 = Car("Toyota", "Corolla")
car2 = Car("Honda", "Civic")

print(car1.make)  # Output: Toyota
print(car2.make)  # Output: Honda
```

### 2.2 Class Attributes
- Defined directly within the class body.
- Shared by all instances of the class.

#### Example:
```python
class Car:
    wheels = 4  # Class attribute

    def __init__(self, make, model):
        self.make = make
        self.model = model

# Access class attribute
print(Car.wheels)  # Output: 4

car = Car("Toyota", "Corolla")
print(car.wheels)  # Output: 4
```

---

## 3. **Accessing Data Attributes**

### Access via Instance:
Instance attributes can be accessed directly using the dot notation.
```python
car = Car("Ford", "Mustang")
print(car.make)  # Output: Ford
```

### Access via Class:
Class attributes can be accessed using the class name or an instance.
```python
print(Car.wheels)  # Output: 4
```

---

## 4. **Modifying Data Attributes**

### Modifying Instance Attributes:
Instance attributes can be modified independently for each object.
```python
car1 = Car("Ford", "Fiesta")
car2 = Car("BMW", "X5")

car1.make = "Audi"
print(car1.make)  # Output: Audi
print(car2.make)  # Output: BMW
```

### Modifying Class Attributes:
Class attributes can be modified using the class name. This change will reflect in all instances unless overridden by an instance-specific value.
```python
Car.wheels = 6
car1 = Car("Ford", "Fiesta")
print(car1.wheels)  # Output: 6
```

---

## 5. **Dynamic Attribute Assignment**

Attributes can be dynamically added to objects at runtime.

#### Example:
```python
class Animal:
    pass

cat = Animal()
cat.name = "Whiskers"  # Dynamically added attribute
print(cat.name)  # Output: Whiskers
```

---

## 6. **Deleting Attributes**

Attributes can be deleted using the `del` keyword.

#### Example:
```python
class Person:
    def __init__(self, name):
        self.name = name

person = Person("Alice")
print(person.name)  # Output: Alice

del person.name
# print(person.name)  # AttributeError: 'Person' object has no attribute 'name'
```

---

## 7. **Best Practices for Data Attributes**

1. **Encapsulation:**
   - Use private or protected attributes (`_attribute` or `__attribute`) to restrict direct access.
   - Provide getter and setter methods if necessary.

2. **Use Class Attributes Wisely:**
   - Avoid modifying class attributes from instances to prevent unintended side effects.

3. **Initialize in Constructor:**
   - Define all instance attributes in the `__init__` method to maintain clarity.

4. **Avoid Excessive Dynamism:**
   - Avoid dynamically adding too many attributes to maintain structure and predictability.

---

## 8. **Conclusion**

Data attributes are an essential part of Python's object-oriented programming paradigm, allowing developers to define and manage the state of objects. Understanding the difference between instance and class attributes, and using them appropriately, is critical for writing clean, maintainable, and effective Python code.

<a id='function-attributes'></a>
# Function Attributes in Python

In Python, functions are first-class objects. This means that they can have attributes just like any other object. Function attributes allow you to attach additional information or metadata to a function, which can be used for various purposes such as debugging, customization, or adding functionality.

---

## 1. **What Are Function Attributes?**

### Key Characteristics:
1. **User-Defined Properties:**
   - You can assign arbitrary attributes to a function.
2. **Stored in `__dict__`:**
   - Function attributes are stored in a function's `__dict__` attribute.
3. **Persistent Across Calls:**
   - The attributes persist as long as the function object exists.

### Example:
```python
def greet(name):
    return f"Hello, {name}!"

# Add an attribute to the function
greet.language = "English"

print(greet.language)  # Output: English
```

---

## 2. **Creating and Accessing Function Attributes**

### Assigning Attributes:
You can assign attributes to a function using the dot notation.
```python
def add(a, b):
    return a + b

# Add custom attributes
add.description = "Adds two numbers"
add.version = 1.0

print(add.description)  # Output: Adds two numbers
print(add.version)      # Output: 1.0
```

### Accessing Attributes:
Function attributes can be accessed using the `.__dict__` attribute or directly using dot notation.
```python
print(add.__dict__)  # Output: {'description': 'Adds two numbers', 'version': 1.0}
```

---

## 3. **Use Cases for Function Attributes**

### 3.1 Adding Metadata:
Function attributes can store metadata for documentation or debugging purposes.
```python
def multiply(a, b):
    return a * b

multiply.author = "Alice"
multiply.last_modified = "2025-01-01"

print(multiply.author)  # Output: Alice
print(multiply.last_modified)  # Output: 2025-01-01
```

### 3.2 Customizing Behavior:
Attributes can be used to toggle or modify the behavior of a function.
```python
def toggle_behavior():
    toggle_behavior.enabled = not getattr(toggle_behavior, "enabled", False)
    return toggle_behavior.enabled

print(toggle_behavior())  # Output: True
print(toggle_behavior())  # Output: False
```

### 3.3 Storing State:
Function attributes can be used to maintain state across calls.
```python
def counter():
    counter.count = getattr(counter, "count", 0) + 1
    return counter.count

print(counter())  # Output: 1
print(counter())  # Output: 2
```

---

## 4. **Best Practices for Function Attributes**

1. **Use Meaningful Names:**
   - Use clear and descriptive names for attributes to avoid confusion.

2. **Avoid Overuse:**
   - Use function attributes sparingly to prevent cluttering the function object.

3. **Consider Alternatives:**
   - For complex state management, consider using classes or closures instead.

4. **Document Attributes:**
   - Provide documentation or comments to explain the purpose of custom attributes.

---

## 5. **Limitations of Function Attributes**

1. **Namespace Clashes:**
   - Avoid attribute names that clash with built-in function properties like `__name__` or `__doc__`.

2. **Not Immutable:**
   - Function attributes can be modified or deleted, which might lead to unexpected behavior.

3. **Not a Replacement for Classes:**
   - Function attributes are not a substitute for classes when dealing with complex state or behavior.

---

## 6. **Practical Example: Function Registry**

### Example:
Using function attributes to register functions.
```python
registry = []

def register(func):
    func.is_registered = True
    registry.append(func)
    return func

@register
def greet():
    return "Hello!"

@register
def farewell():
    return "Goodbye!"

print([f.__name__ for f in registry])  # Output: ['greet', 'farewell']
```

---

## 7. **Conclusion**

Function attributes in Python provide a powerful and flexible way to attach additional information to functions. While they should be used judiciously, they can simplify certain use cases such as maintaining state, storing metadata, or customizing behavior. By understanding their capabilities and limitations, you can effectively leverage function attributes to enhance your Python code.

<a id='initializing-instances'></a>
# Initializing Class Instances in Python

In Python, initializing a class instance refers to the process of setting up the initial state of an object when it is created. This is typically done using the `__init__` method, which is a special method that gets called automatically when a new instance of a class is created.

---

## 1. **The `__init__` Method**

The `__init__` method is a constructor in Python that is used to initialize the attributes of a class instance.

### Syntax:
```python
class ClassName:
    def __init__(self, parameters):
        # Initialization logic
        self.attribute = value
```

### Example:
```python
class Person:
    def __init__(self, name, age):
        self.name = name  # Instance attribute
        self.age = age    # Instance attribute

# Creating an instance
person = Person("Alice", 30)
print(person.name)  # Output: Alice
print(person.age)   # Output: 30
```

---

## 2. **Default Values in `__init__`**

You can provide default values for parameters in the `__init__` method, allowing for more flexible instance creation.

### Example:
```python
class Car:
    def __init__(self, make, model, year=2023):
        self.make = make
        self.model = model
        self.year = year

# Creating instances
car1 = Car("Toyota", "Corolla")
car2 = Car("Honda", "Civic", 2020)

print(car1.year)  # Output: 2023
print(car2.year)  # Output: 2020
```

---

## 3. **Optional Attributes**

Not all attributes need to be initialized in the `__init__` method. Optional attributes can be added dynamically after instance creation.

### Example:
```python
class Animal:
    def __init__(self, species):
        self.species = species

# Adding attributes dynamically
animal = Animal("Dog")
animal.name = "Buddy"

print(animal.name)  # Output: Buddy
```

---

## 4. **Type Annotations in `__init__`**

Python supports type annotations to make the expected types of attributes explicit.

### Example:
```python
class Rectangle:
    def __init__(self, width: float, height: float):
        self.width = width
        self.height = height

rect = Rectangle(5.0, 10.0)
print(rect.width, rect.height)  # Output: 5.0 10.0
```

---

## 5. **Using `__post_init__` with `dataclasses`**

For classes created with the `@dataclass` decorator, additional initialization logic can be added using the `__post_init__` method.

### Example:
```python
from dataclasses import dataclass

@dataclass
class Product:
    name: str
    price: float

    def __post_init__(self):
        if self.price < 0:
            raise ValueError("Price cannot be negative")

product = Product("Laptop", 1000)
print(product)  # Output: Product(name='Laptop', price=1000)
```

---

## 6. **Using `super()` in `__init__`**

When a class inherits from another, you can use `super()` to call the parent class's `__init__` method.

### Example:
```python
class Employee:
    def __init__(self, name, id):
        self.name = name
        self.id = id

class Manager(Employee):
    def __init__(self, name, id, department):
        super().__init__(name, id)
        self.department = department

manager = Manager("Bob", 123, "Sales")
print(manager.name)       # Output: Bob
print(manager.department) # Output: Sales
```

---

## 7. **Best Practices for Initializing Class Instances**

1. **Use Default Values Wisely:**
   - Provide default values for attributes when it makes sense to do so.

2. **Validate Input:**
   - Perform input validation within the `__init__` method to ensure data integrity.

3. **Keep Initialization Simple:**
   - Avoid overloading the `__init__` method with excessive logic. Use helper methods if needed.

4. **Use Type Annotations:**
   - Make your code more readable and less error-prone by specifying type annotations.

5. **Follow Encapsulation Principles:**
   - Use private attributes (e.g., `self.__attribute`) if you want to restrict direct access to them.

---

## 8. **Common Pitfalls**

1. **Overcomplicating Initialization:**
   - Avoid putting too much logic in the `__init__` method.

2. **Misusing Class Attributes:**
   - Be cautious not to mix class attributes with instance attributes unintentionally.

3. **Not Using `super()` Correctly:**
   - Always call `super().__init__()` when dealing with inheritance.

---

## 9. **Conclusion**

Initializing class instances is a fundamental aspect of Python's object-oriented programming. By leveraging the `__init__` method, default values, and type annotations, you can create clear, flexible, and maintainable class constructors. Proper initialization ensures that objects are correctly set up and ready for use in your programs.
<a id='run-time'></a>
# Creating Attributes at Runtime in Python

In Python, attributes can be created and assigned to objects dynamically at runtime. This feature provides flexibility and allows developers to extend objects' functionality on-the-fly. However, with this power comes the responsibility to use it judiciously to maintain code readability and robustness.

---

## 1. **What Does It Mean to Create Attributes at Runtime?**

### Key Characteristics:
1. **Dynamic Assignment:**
   - Attributes are added to an object after it has been created.
2. **No Restrictions:**
   - Any valid attribute name can be added as long as the object allows it.
3. **Stored in `__dict__`:**
   - Dynamically created attributes are stored in the object's `__dict__` (if it exists).

### Example:
```python
class Dynamic:
    pass

obj = Dynamic()
obj.name = "Dynamic Object"
obj.value = 42

print(obj.name)  # Output: Dynamic Object
print(obj.value) # Output: 42
```

---

## 2. **Adding Attributes Dynamically**

Attributes can be added directly using the dot notation or by modifying the object's `__dict__`.

### Example 1: Using Dot Notation
```python
class Animal:
    def __init__(self, species):
        self.species = species

# Dynamically add attributes
animal = Animal("Dog")
animal.name = "Buddy"
animal.age = 5

print(animal.name)  # Output: Buddy
print(animal.age)   # Output: 5
```

### Example 2: Using `__dict__`
```python
class Example:
    pass

obj = Example()
obj.__dict__["attribute"] = "Value from __dict__"
print(obj.attribute)  # Output: Value from __dict__
```

---

## 3. **Dynamic Attribute Creation with `setattr()`**

The `setattr()` function can be used to add or modify attributes dynamically.

### Syntax:
```python
setattr(object, attribute_name, value)
```

### Example:
```python
class Car:
    def __init__(self, make):
        self.make = make

car = Car("Toyota")
setattr(car, "model", "Corolla")
setattr(car, "year", 2023)

print(car.model)  # Output: Corolla
print(car.year)   # Output: 2023
```

---

## 4. **Use Cases for Runtime Attribute Creation**

### 4.1 Extending Objects:
Add new attributes to objects to extend their functionality dynamically.
```python
class User:
    def __init__(self, username):
        self.username = username

user = User("johndoe")
user.email = "johndoe@example.com"

print(user.email)  # Output: johndoe@example.com
```

### 4.2 Dynamic Data Structures:
Store arbitrary key-value pairs in objects for flexibility.
```python
class Record:
    pass

record = Record()
fields = {"name": "Alice", "age": 30, "city": "New York"}

for key, value in fields.items():
    setattr(record, key, value)

print(record.name)  # Output: Alice
print(record.city)  # Output: New York
```

### 4.3 Wrapping APIs:
Dynamically create attributes to wrap responses from external APIs.
```python
class ApiResponse:
    def __init__(self, data):
        for key, value in data.items():
            setattr(self, key, value)

response_data = {"status": "success", "message": "Data retrieved", "code": 200}
response = ApiResponse(response_data)

print(response.status)  # Output: success
print(response.code)    # Output: 200
```

---

## 5. **Preventing Dynamic Attribute Creation**

In some cases, you may want to restrict objects from allowing new attributes to be added dynamically. This can be achieved using `__slots__`.

### Example:
```python
class Person:
    __slots__ = ["name", "age"]

    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Bob", 25)
person.name = "Alice"
# person.address = "Unknown"  # AttributeError: 'Person' object has no attribute 'address'
```

---

## 6. **Best Practices for Runtime Attributes**

1. **Use Sparingly:**
   - Avoid excessive use of dynamic attributes, as they can make the code harder to read and debug.

2. **Validate Input:**
   - Ensure that attribute names and values are validated before adding them dynamically.

3. **Consider Alternatives:**
   - Use dictionaries or data classes if arbitrary key-value pairs are needed.

4. **Document Usage:**
   - Clearly document the use of dynamic attributes to make the code easier to understand for other developers.

---

## 7. **Limitations of Dynamic Attributes**

1. **Lack of Predictability:**
   - Dynamically added attributes are not immediately visible, which can lead to confusion.

2. **Error-Prone:**
   - Typos in attribute names can introduce subtle bugs.

3. **Compatibility Issues:**
   - Some Python tools (e.g., linters or type checkers) may not recognize dynamically added attributes.

---

## 8. **Conclusion**

Creating attributes at runtime in Python provides a powerful way to extend and customize objects dynamically. While this feature adds flexibility, it should be used judiciously to avoid potential pitfalls such as reduced code readability and increased risk of errors. By following best practices, dynamic attributes can be an effective tool for building flexible and dynamic Python applications.

<a id='properties'></a>
# Class Properties in Python

Class properties in Python are a way to encapsulate methods in a class that behave like attributes. They allow developers to define getter, setter, and deleter methods for attributes, ensuring better control and encapsulation of class data.

---

## 1. **What Are Class Properties?**

### Key Characteristics:
1. **Encapsulation:**
   - Provide controlled access to class or instance attributes.
2. **Attribute-Like Access:**
   - Access methods using dot notation, just like regular attributes.
3. **Flexible Logic:**
   - Add logic for computation, validation, or formatting when getting or setting attributes.

### Example:
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

circle = Circle(5)
print(circle.radius)  # Output: 5

circle.radius = 10
print(circle.radius)  # Output: 10

# circle.radius = -1  # Raises ValueError: Radius must be positive
```

---

## 2. **Defining Class Properties**

### 2.1 The `@property` Decorator
The `@property` decorator converts a method into a getter for an attribute.

#### Example:
```python
class Square:
    def __init__(self, side):
        self._side = side

    @property
    def area(self):
        return self._side ** 2

square = Square(4)
print(square.area)  # Output: 16
```

### 2.2 Adding Setters
Setters allow attributes to be modified while adding validation or other logic.

#### Example:
```python
class Square:
    def __init__(self, side):
        self._side = side

    @property
    def side(self):
        return self._side

    @side.setter
    def side(self, value):
        if value <= 0:
            raise ValueError("Side length must be positive")
        self._side = value

square = Square(4)
square.side = 5
print(square.side)  # Output: 5
```

### 2.3 Adding Deleters
Deleters allow controlled deletion of attributes.

#### Example:
```python
class Data:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

    @value.deleter
    def value(self):
        print("Deleting value")
        del self._value

obj = Data(10)
del obj.value  # Output: Deleting value
```

---

## 3. **Advantages of Using Class Properties**

1. **Encapsulation:**
   - Keep attribute access and modification logic within the class.
2. **Validation:**
   - Ensure data integrity by validating inputs in setter methods.
3. **Readability:**
   - Simplify code by using attribute-like syntax instead of method calls.
4. **Compatibility:**
   - Transition from public attributes to properties without breaking existing code.

---

## 4. **Read-Only Properties**

Use properties to make attributes read-only by omitting the setter.

#### Example:
```python
class Immutable:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

obj = Immutable(42)
print(obj.value)  # Output: 42
# obj.value = 100  # AttributeError: can't set attribute
```

---

## 5. **Class-Level Properties**

Class-level properties can be created using the `@classmethod` decorator with `@property`.

#### Example:
```python
class Settings:
    _version = "1.0"

    @classmethod
    @property
    def version(cls):
        return cls._version

print(Settings.version)  # Output: 1.0
```

---

## 6. **Combining Properties with Inheritance**

Properties can be overridden or extended in subclasses.

#### Example:
```python
class Shape:
    @property
    def description(self):
        return "This is a shape"

class Circle(Shape):
    @property
    def description(self):
        return "This is a circle"

circle = Circle()
print(circle.description)  # Output: This is a circle
```

---

## 7. **Best Practices for Class Properties**

1. **Keep Logic Minimal:**
   - Avoid adding excessive logic to property methods.

2. **Use for Encapsulation:**
   - Replace public attributes with properties when validation or computed values are needed.

3. **Document Properties:**
   - Clearly document property methods to explain their purpose.

4. **Avoid Overusing Properties:**
   - Use properties sparingly for clarity and maintainability.

---

## 8. **Common Pitfalls**

1. **Performance Overhead:**
   - Properties are not cached, so repeated access may impact performance. Use `functools.cached_property` if caching is needed.

2. **Overcomplicating Logic:**
   - Avoid adding complex logic to getters or setters.

3. **Inconsistent Behavior:**
   - Ensure consistent behavior between getter, setter, and deleter methods.

---

## 9. **Conclusion**

Class properties in Python offer a clean and controlled way to manage access to class attributes. By using properties, you can encapsulate logic for getting, setting, and deleting attributes, ensuring better data integrity and maintainability. Proper use of properties can significantly improve the clarity and robustness of your code.
<a id='property-decorator'></a>
# The `@property` Decorator in Python

The `@property` decorator in Python is a powerful tool that allows you to define methods that can be accessed like attributes. It is commonly used for encapsulation, computed properties, and attribute validation while maintaining a clean and intuitive interface.

---

## 1. **What is the `@property` Decorator?**

### Key Features:
1. **Encapsulation:**
   - Provides controlled access to instance attributes.
2. **Attribute-Like Syntax:**
   - Allows methods to be accessed like attributes without explicit parentheses.
3. **Read-Only or Read-Write:**
   - Properties can be defined as read-only or with both getter and setter functionality.

### Example:
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

circle = Circle(5)
print(circle.radius)  # Output: 5

circle.radius = 10
print(circle.radius)  # Output: 10

# circle.radius = -1  # Raises ValueError: Radius must be positive
```

---

## 2. **How Does `@property` Work?**

The `@property` decorator wraps a method and makes it accessible as an attribute. You can add a setter and deleter to control assignment and deletion.

### Syntax:
```python
class ClassName:
    @property
    def attribute(self):
        # Getter method

    @attribute.setter
    def attribute(self, value):
        # Setter method

    @attribute.deleter
    def attribute(self):
        # Deleter method
```

---

## 3. **Defining Read-Only Properties**

A property can be read-only by omitting the setter.

### Example:
```python
class Square:
    def __init__(self, side):
        self._side = side

    @property
    def area(self):
        return self._side ** 2

square = Square(4)
print(square.area)  # Output: 16
# square.area = 25  # AttributeError: can't set attribute
```

---

## 4. **Defining Writable Properties**

Add a setter to allow modifications.

### Example:
```python
class Square:
    def __init__(self, side):
        self._side = side

    @property
    def side(self):
        return self._side

    @side.setter
    def side(self, value):
        if value <= 0:
            raise ValueError("Side length must be positive")
        self._side = value

square = Square(4)
square.side = 5
print(square.side)  # Output: 5
```

---

## 5. **Deleting Properties**

Use the `@deleter` decorator to define logic for deleting an attribute.

### Example:
```python
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.deleter
    def name(self):
        print("Deleting name")
        del self._name

person = Person("Alice")
del person.name  # Output: Deleting name
```

---

## 6. **Benefits of Using `@property`**

1. **Encapsulation:**
   - Keep the internal representation of attributes private.

2. **Lazy Computation:**
   - Compute attribute values only when accessed.

3. **Backward Compatibility:**
   - Convert public attributes to properties without breaking existing code.

4. **Validation:**
   - Add validation logic in setters.

---

## 7. **Common Use Cases**

### 7.1 Computed Properties:
Automatically calculate attribute values.
```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        return self._width * self._height

rect = Rectangle(4, 5)
print(rect.area)  # Output: 20
```

### 7.2 Validation:
Enforce rules for attribute values.
```python
class BankAccount:
    def __init__(self, balance):
        self._balance = balance

    @property
    def balance(self):
        return self._balance

    @balance.setter
    def balance(self, value):
        if value < 0:
            raise ValueError("Balance cannot be negative")
        self._balance = value

account = BankAccount(100)
account.balance = 200
print(account.balance)  # Output: 200
```

### 7.3 Read-Only Constants:
Provide access to constants without allowing modification.
```python
class Config:
    @property
    def version(self):
        return "1.0"

config = Config()
print(config.version)  # Output: 1.0
# config.version = "2.0"  # AttributeError
```

---

## 8. **Best Practices**

1. **Use Meaningful Names:**
   - Ensure property names clearly describe their purpose.

2. **Keep Logic Simple:**
   - Avoid complex calculations or logic in property methods.

3. **Document Properties:**
   - Add docstrings to explain the purpose of properties.

4. **Avoid Overuse:**
   - Use properties only when necessary for encapsulation or validation.

5. **Consider Performance:**
   - Use `functools.cached_property` for expensive computations that don’t change.

---

## 9. **Limitations of `@property`**

1. **Performance Overhead:**
   - Properties introduce a function call overhead compared to direct attribute access.

2. **Not Introspectable:**
   - Properties are less explicit than attributes, which can make debugging harder.

3. **May Obscure Logic:**
   - Excessive use of properties can reduce code clarity.

---

## 10. **Conclusion**

The `@property` decorator is a powerful tool in Python for managing attribute access. It enables encapsulation, validation, and computed properties while maintaining clean and intuitive syntax. By understanding its capabilities and best practices, you can enhance the readability, maintainability, and robustness of your Python code.

<a id='read-only'></a>
# Read-Only and Computed Properties in Python

Read-only and computed properties in Python are special class attributes created using the `@property` decorator. They enable controlled access to class data, provide validation, and allow for dynamic computation of attribute values, ensuring encapsulation and enhanced readability.

---

## 1. **What are Read-Only Properties?**

### Key Characteristics:
1. **Immutable Access:**
   - Users can retrieve the value of an attribute but cannot modify it.
2. **Encapsulation:**
   - Prevents direct manipulation of internal attributes.
3. **Defined Without a Setter:**
   - A property without a `@setter` remains read-only.

### Example:
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

circle = Circle(5)
print(circle.radius)  # Output: 5
# circle.radius = 10  # Raises AttributeError: can't set attribute
```

### Use Case:
Read-only properties are ideal for constants or derived values that should not be changed after initialization.

---

## 2. **What are Computed Properties?**

### Key Characteristics:
1. **Dynamically Computed Values:**
   - The value of the property is calculated on the fly when accessed.
2. **Encapsulation:**
   - Hides complex logic behind a simple attribute-like interface.
3. **Automatic Recalculation:**
   - Computed properties always reflect the current state of dependent attributes.

### Example:
```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        return self._width * self._height

rect = Rectangle(4, 5)
print(rect.area)  # Output: 20

rect._width = 6
print(rect.area)  # Output: 30
```

### Use Case:
Computed properties are commonly used for derived values such as mathematical calculations, dynamic formatting, or conditional attributes.

---

## 3. **Combining Read-Only and Computed Properties**

Properties can be both read-only and computed, providing immutable access to dynamically calculated values.

### Example:
```python
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def fahrenheit(self):
        return self._celsius * 9 / 5 + 32

temp = Temperature(25)
print(temp.fahrenheit)  # Output: 77.0
# temp.fahrenheit = 80  # Raises AttributeError: can't set attribute
```

---

## 4. **Advantages of Read-Only and Computed Properties**

1. **Encapsulation:**
   - Keeps internal logic hidden from the user.
2. **Improved Readability:**
   - Simplifies access to derived or dynamic values using attribute-like syntax.
3. **Data Integrity:**
   - Prevents accidental modification of critical or derived values.
4. **Dynamic Behavior:**
   - Always reflects the most up-to-date state of the object.

---

## 5. **Best Practices for Read-Only and Computed Properties**

1. **Keep Logic Simple:**
   - Avoid complex calculations in property methods to maintain performance.

2. **Use for Important or Derived Data:**
   - Reserve properties for values that require validation, computation, or controlled access.

3. **Document Properties:**
   - Clearly explain the purpose and behavior of the property in its docstring.

4. **Use Private Attributes:**
   - Back properties with private or protected attributes to prevent direct access.

5. **Consider Caching for Expensive Computations:**
   - Use `functools.cached_property` for properties that involve heavy computation.

---

## 6. **Caching Computed Properties**

For expensive computed properties, use `functools.cached_property` to cache the computed value after the first access.

### Example:
```python
from functools import cached_property

class DataLoader:
    def __init__(self, data):
        self.data = data

    @cached_property
    def processed_data(self):
        print("Processing data...")
        return [x ** 2 for x in self.data]

loader = DataLoader([1, 2, 3])
print(loader.processed_data)  # Output: Processing data... [1, 4, 9]
print(loader.processed_data)  # Output: [1, 4, 9] (no reprocessing)
```

---

## 7. **Limitations and Caveats**

1. **Performance Overhead:**
   - Computed properties are recalculated every time they are accessed unless cached.

2. **Not Introspectable:**
   - It may be less obvious to developers that a property is computed, leading to debugging challenges.

3. **Overuse:**
   - Avoid overloading classes with too many properties as it can obscure the object’s true behavior.

4. **Mutability:**
   - Read-only properties do not prevent changes to the underlying data unless explicitly enforced.

---

## 8. **Conclusion**

Read-only and computed properties are powerful tools in Python that enhance object-oriented design. By encapsulating logic behind attribute-like access, they provide a clean, user-friendly interface for complex or sensitive data. Understanding when and how to use these properties effectively can significantly improve the readability, maintainability, and reliability of your Python code.

<a id='deleting'></a>
# Deleting Properties in Python

Python provides the ability to define logic for deleting attributes through the `@property` decorator and its associated `@deleter`. This allows for controlled removal of attributes and ensures that custom cleanup or validation logic can be executed during the deletion process.

---

## 1. **Why Delete Properties?**

Deleting properties can be useful in scenarios such as:
- Cleaning up resources associated with an attribute.
- Restricting or controlling attribute deletion.
- Logging or debugging purposes.

---

## 2. **How to Define a Deleter with `@property`**

To define a deleter, use the `@property.deleter` decorator. This decorator attaches a custom method that will be executed when the `del` statement is used on the property.

### Example:
```python
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.deleter
    def name(self):
        print("Deleting name...")
        del self._name

person = Person("Alice")
print(person.name)  # Output: Alice

del person.name  # Output: Deleting name...
# print(person.name)  # AttributeError: 'Person' object has no attribute '_name'
```

---

## 3. **Custom Cleanup Logic**

When deleting a property, you can define custom logic to handle resource cleanup or additional tasks.

### Example:
```python
class FileHandler:
    def __init__(self, filename):
        self._filename = filename
        self._file = open(filename, 'w')

    @property
    def file(self):
        return self._file

    @file.deleter
    def file(self):
        print(f"Closing file: {self._filename}")
        self._file.close()
        del self._file

handler = FileHandler("example.txt")
del handler.file  # Output: Closing file: example.txt
```

---

## 4. **Restricting Deletion of Attributes**

You can raise exceptions in the deleter to prevent certain attributes from being deleted.

### Example:
```python
class ProtectedAttribute:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        return self._value

    @value.deleter
    def value(self):
        raise AttributeError("Deletion of 'value' is not allowed")

obj = ProtectedAttribute(42)
# del obj.value  # Raises AttributeError: Deletion of 'value' is not allowed
```

---

## 5. **Best Practices for Using Deleters**

1. **Use Sparingly:**
   - Only use deleters when necessary, as they can add complexity to your code.

2. **Document Behavior:**
   - Clearly document what happens when a property is deleted, especially if it involves resource cleanup or raises exceptions.

3. **Avoid Overuse:**
   - For most scenarios, explicit cleanup methods (e.g., `close()` or `cleanup()`) are more appropriate than relying on deleters.

4. **Handle Exceptions Gracefully:**
   - Ensure deleters handle errors gracefully to avoid leaving objects in an inconsistent state.

---

## 6. **Limitations and Caveats**

1. **May Obscure Behavior:**
   - Deleters can make code less explicit, as the deletion logic is hidden behind the `del` statement.

2. **Not Always Necessary:**
   - For straightforward cleanup tasks, explicitly defined methods are often more readable and intuitive.

3. **Interference with Garbage Collection:**
   - Python’s garbage collector may handle resource cleanup in some cases, making deleters redundant.

---

## 7. **When to Use Deleters**

- Managing external resources like file handles, database connections, or network sockets.
- Validating or logging attribute deletion.
- Preventing the deletion of critical attributes.

---

## 8. **Conclusion**

The `@property.deleter` decorator in Python is a powerful tool for controlling and customizing attribute deletion. By leveraging this feature, you can implement robust cleanup logic and ensure better control over your object’s lifecycle. However, it’s essential to use deleters judiciously to maintain code readability and avoid unnecessary complexity.

<a id='class-static'></a>
# Class Methods vs Static Methods vs Instance Methods in Python

Python supports three distinct types of methods in a class: instance methods, class methods, and static methods. Each type serves a different purpose and is distinguished by how it operates on class or instance data.

---

## 1. **Instance Methods**

### Key Features:
1. **Operate on Instance Data:**
   - Instance methods take `self` as their first parameter, which represents the instance of the class.
2. **Can Modify Object State:**
   - Instance methods can access and modify instance attributes and call other instance methods.
3. **Called on Instances:**
   - Typically invoked using an instance of the class.

### Example:
```python
class Dog:
    def __init__(self, name):
        self.name = name

    def bark(self):
        return f"{self.name} says Woof!"

# Usage
dog = Dog("Buddy")
print(dog.bark())  # Output: Buddy says Woof!
```

---

## 2. **Class Methods**

### Key Features:
1. **Operate on Class Data:**
   - Class methods take `cls` as their first parameter, which represents the class itself.
2. **Access Class Attributes:**
   - Useful for methods that deal with class-level attributes or behaviors.
3. **Defined Using `@classmethod`:**
   - Decorate a method with `@classmethod` to make it a class method.
4. **Can Be Called on Class or Instance:**
   - Invoked using the class or an instance.

### Example:
```python
class Animal:
    species = "Animal"

    @classmethod
    def set_species(cls, new_species):
        cls.species = new_species

# Usage
print(Animal.species)  # Output: Animal
Animal.set_species("Mammal")
print(Animal.species)  # Output: Mammal
```

---

## 3. **Static Methods**

### Key Features:
1. **Do Not Operate on Class or Instance Data:**
   - Static methods neither take `self` nor `cls` as their first parameter.
2. **Utility-Like Behavior:**
   - Used for methods that perform tasks in isolation without requiring access to class or instance data.
3. **Defined Using `@staticmethod`:**
   - Decorate a method with `@staticmethod` to make it a static method.
4. **Can Be Called on Class or Instance:**
   - Invoked using the class or an instance.

### Example:
```python
class Math:
    @staticmethod
    def add(a, b):
        return a + b

# Usage
print(Math.add(3, 5))  # Output: 8
```

---

## 4. **Comparison Table**

| Feature                  | Instance Method            | Class Method              | Static Method             |
|--------------------------|----------------------------|---------------------------|---------------------------|
| **First Parameter**      | `self` (instance)          | `cls` (class)             | None                      |
| **Access Instance Data** | Yes                        | No                        | No                        |
| **Access Class Data**    | Yes                        | Yes                       | No                        |
| **Requires Instance**    | Yes                        | No                        | No                        |
| **Requires Class**       | No                         | Yes                       | No                        |
| **Decorator**            | None                       | `@classmethod`            | `@staticmethod`           |

---

## 5. **When to Use Each Method Type**

### 5.1 Instance Methods:
- Use when you need to access or modify the object’s state (instance attributes).

### 5.2 Class Methods:
- Use when you need to operate on class-level data or implement factory methods.

### 5.3 Static Methods:
- Use when the logic is independent of the class and instance. Suitable for utility functions.

---

## 6. **Example: Combining All Method Types**

```python
class Temperature:
    scale = "Celsius"  # Class attribute

    def __init__(self, value):
        self.value = value  # Instance attribute

    def to_fahrenheit(self):
        return (self.value * 9/5) + 32

    @classmethod
    def set_scale(cls, scale):
        cls.scale = scale

    @staticmethod
    def freezing_point(scale):
        if scale == "Celsius":
            return 0
        elif scale == "Fahrenheit":
            return 32
        else:
            raise ValueError("Unknown scale")

# Usage
# Instance Method
temp = Temperature(25)
print(temp.to_fahrenheit())  # Output: 77.0

# Class Method
Temperature.set_scale("Fahrenheit")
print(Temperature.scale)  # Output: Fahrenheit

# Static Method
print(Temperature.freezing_point("Celsius"))  # Output: 0
```

---

## 7. **Best Practices**

1. **Choose the Right Method Type:**
   - Use instance methods for behaviors tied to an object.
   - Use class methods for class-wide operations or factory methods.
   - Use static methods for isolated, utility-like functions.

2. **Keep Methods Simple:**
   - Avoid mixing concerns. Stick to the method's specific role (instance, class, or static).

3. **Document Purpose Clearly:**
   - Use docstrings to explain the intent and usage of each method type.

---

## 8. **Conclusion**

Understanding the differences between instance, class, and static methods is crucial for writing clean, modular, and maintainable Python code. Each method type serves a specific purpose, and choosing the appropriate one can enhance the design and clarity of your class-based programs.

<a id='class-body'></a>
# Class Body Scope in Python

The class body scope in Python defines the environment where the statements inside a class definition are executed. This scope is critical for understanding how class attributes, methods, and other declarations behave and interact during class definition and at runtime.

---

## 1. **What is the Class Body Scope?**

### Key Characteristics:
1. **Execution Scope:**
   - The class body is executed in a local scope, which becomes the namespace of the class.
2. **Namespace Creation:**
   - Attributes and methods declared in the class body are stored in the class’s namespace.
3. **Not a Regular Scope:**
   - Unlike function scopes, the class body scope is transient, and its namespace is discarded after the class is created.

### Example:
```python
class Example:
    x = 10  # Class attribute

    def method(self):
        return self.x

# Accessing the namespace
print(Example.__dict__)  # Output includes 'x' and 'method'
```

---

## 2. **How the Class Body is Executed**

1. **Execution Order:**
   - Statements inside the class body are executed in the order they are written.
   - Attributes and methods are added to the class namespace as they are defined.

2. **Namespace:**
   - The namespace of the class is local to the class definition and is accessible via `__dict__`.

3. **After Class Creation:**
   - The local namespace is discarded, and the class itself becomes an object.

### Example:
```python
class Demo:
    print("Class body is being executed")

    x = 42

    def func(self):
        return self.x

print(Demo.x)  # Output: 42
```

---

## 3. **Accessing Class Attributes**

Class attributes defined in the class body are accessible via the class name or an instance.

### Example:
```python
class MyClass:
    value = 100

# Access via class
print(MyClass.value)  # Output: 100

# Access via instance
obj = MyClass()
print(obj.value)  # Output: 100
```

---

## 4. **Dynamic Modifications to the Class Namespace**

Attributes and methods can be added dynamically to the class during or after its creation.

### Example:
```python
class DynamicClass:
    pass

# Adding attributes dynamically
DynamicClass.new_attribute = "Dynamic Value"
print(DynamicClass.new_attribute)  # Output: Dynamic Value
```

---

## 5. **Variables in the Class Body Scope**

Variables in the class body are local to the class definition and do not persist as instance attributes unless explicitly assigned.

### Example:
```python
class Test:
    temp = 10

    def __init__(self):
        self.instance_var = Test.temp

print(Test.temp)  # Output: 10
obj = Test()
print(obj.instance_var)  # Output: 10
```

---

## 6. **Special Variables in the Class Scope**

1. **`__name__`:**
   - The name of the class.
2. **`__module__`:**
   - The module in which the class was defined.
3. **`__dict__`:**
   - A dictionary containing the class’s namespace.

### Example:
```python
class SpecialVariables:
    x = 5

print(SpecialVariables.__name__)   # Output: SpecialVariables
print(SpecialVariables.__module__) # Output: __main__
print(SpecialVariables.__dict__)   # Includes 'x'
```

---

## 7. **Limitations of the Class Body Scope**

1. **No Direct Access to Instance Attributes:**
   - The `self` keyword is not available in the class body.

2. **Temporary Scope:**
   - The local scope during class definition is discarded after the class object is created.

3. **Execution Context:**
   - Class body execution happens before the class object is created, which can lead to confusion about when certain attributes are available.

---

## 8. **Best Practices**

1. **Define Attributes Explicitly:**
   - Clearly distinguish between class attributes and instance attributes.

2. **Avoid Overcomplicating the Class Body:**
   - Keep the class body simple to avoid unexpected behavior.

3. **Document Special Variables:**
   - Use comments to explain the purpose of special variables like `__dict__` and `__module__`.

4. **Minimize Dynamic Modifications:**
   - Avoid excessive dynamic modifications to maintain clarity.

---

## 9. **Conclusion**

The class body scope is an essential concept in Python, determining how class attributes, methods, and special variables are created and accessed. Understanding its behavior allows developers to write more predictable and maintainable class definitions.
