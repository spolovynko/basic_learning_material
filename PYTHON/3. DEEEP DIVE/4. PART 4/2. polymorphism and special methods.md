- [POLYMORPHISM](#polymorphism)
- [STR AND REPR METHODS](#str-repr)
- [ARITHMETIC OPERATORS](#arithmetic)
- [RICH COMPARISONS](#rich-comparisons)
- [HASHING AND EQUALITY](#hashing)
- [BOOLEANS](#booleans)
- [CALLABLES](#callables)
- [DEL METHOD](#del)
- [FORMAT METHOD](#format)
  
<a id='polymorphism'></a>
# Polymorphism in Python

Polymorphism is one of the core principles of object-oriented programming (OOP). It allows objects of different classes to be treated as objects of a common super class. Polymorphism promotes flexibility, scalability, and code reusability by enabling a single interface to work with different types of objects.

---

## 1. **What is Polymorphism?**

### Definition:
Polymorphism, meaning "many forms," allows the same operation or method to behave differently on different classes. In Python, this can be achieved through:

1. **Method Overriding** (Inheritance)
2. **Method Overloading** (Python doesn't support it directly but achieves similar functionality via default arguments.)
3. **Operator Overloading**

---

## 2. **Polymorphism in Action**

### Example 1: Polymorphism with Inheritance
```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

animals = [Dog(), Cat()]
for animal in animals:
    print(animal.speak())
# Output:
# Woof!
# Meow!
```

In this example, both `Dog` and `Cat` implement the `speak` method differently, yet the same interface (`speak`) is used to interact with objects of both classes.

---

## 3. **Operator Overloading**

Python allows operator overloading to extend or change the behavior of operators like `+`, `-`, `*`, etc., for user-defined types.

### Example:
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __repr__(self):
        return f"Point({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
print(p1 + p2)  # Output: Point(4, 6)
```

Here, the `+` operator is overloaded to add two `Point` objects, combining their `x` and `y` coordinates.

---

## 4. **Polymorphism in Built-In Functions**

Many Python functions exhibit polymorphic behavior by working with different types of data.

### Example:
```python
print(len("Hello"))  # Output: 5 (string)
print(len([1, 2, 3, 4]))  # Output: 4 (list)
print(len({"key1": "value1", "key2": "value2"}))  # Output: 2 (dictionary)
```
The `len()` function works with strings, lists, and dictionaries, even though the implementation is different internally.

---

## 5. **Polymorphism with Abstract Classes**

Abstract classes and methods can enforce polymorphism by ensuring derived classes implement certain methods.

### Example:
```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14 * self.radius

shapes = [Rectangle(4, 5), Circle(3)]
for shape in shapes:
    print(f"Area: {shape.area()}, Perimeter: {shape.perimeter()}")
# Output:
# Area: 20, Perimeter: 18
# Area: 28.26, Perimeter: 18.84
```

Here, the abstract class `Shape` enforces a consistent interface for `area` and `perimeter` across its subclasses.

---

## 6. **Polymorphism with Functions and Objects**

You can design functions to work with different types of objects as long as they share a common method or attribute.

### Example:
```python
class Car:
    def start(self):
        return "Car started"

class Bike:
    def start(self):
        return "Bike started"

def vehicle_start(vehicle):
    print(vehicle.start())

vehicle_start(Car())  # Output: Car started
vehicle_start(Bike())  # Output: Bike started
```

The `vehicle_start` function works with any object that implements the `start` method, regardless of its type.

---

## 7. **Advantages of Polymorphism**

1. **Code Reusability:**
   - Write generic functions and classes that work with different types.
2. **Scalability:**
   - Add new types or classes without modifying existing code.
3. **Readability:**
   - Simplify the code by hiding implementation details behind a common interface.

---

## 8. **Best Practices for Using Polymorphism**

1. **Use Abstract Base Classes for Consistency:**
   - Enforce consistent interfaces across subclasses.
2. **Avoid Overcomplicating Operator Overloading:**
   - Ensure overloaded operators are intuitive and meaningful.
3. **Test for Expected Behavior:**
   - Verify that polymorphic methods behave as intended for all supported types.
4. **Follow the Liskov Substitution Principle:**
   - Ensure derived classes can substitute their base classes without altering program behavior.

---

## 9. **Common Pitfalls**

1. **Misusing Operator Overloading:**
   - Overloading operators in ways that are unintuitive can confuse users.
2. **Excessive Type Checking:**
   - Avoid type checks that defeat the purpose of polymorphism.
3. **Neglecting Documentation:**
   - Clearly document polymorphic behaviors and expectations for your methods.

---

## 10. **Conclusion**

Polymorphism is a cornerstone of Python’s flexibility and power in object-oriented programming. By leveraging polymorphism, developers can write cleaner, reusable, and more maintainable code that easily adapts to new requirements. Understanding and applying polymorphism effectively is key to mastering Python and designing robust, scalable applications.
<a id='str-repr'></a>
# `__str__` and `__repr__` Methods in Python

The `__str__` and `__repr__` methods in Python are special methods used to provide string representations of objects. These methods are crucial for debugging, logging, and presenting object information in a human-readable or developer-friendly way.

---

## 1. **What are `__str__` and `__repr__`?**

### **`__repr__` (Developer-Friendly Representation):**
- Purpose: To provide an unambiguous string representation of the object, primarily for debugging and logging.
- Should return a string that, ideally, can be used to recreate the object.
- Accessed using the `repr()` function or in contexts like interactive Python shells.

### **`__str__` (User-Friendly Representation):**
- Purpose: To provide a readable and user-friendly string representation of the object.
- Accessed using the `str()` function or when using `print()` on an object.
- Falls back to `__repr__` if `__str__` is not defined.

---

## 2. **Difference Between `__str__` and `__repr__`**

| Feature             | `__repr__`                   | `__str__`                     |
|---------------------|------------------------------|-------------------------------|
| **Primary Use**     | Developer debugging          | User-friendly display         |
| **Accessed By**     | `repr(obj)` or shell output  | `str(obj)` or `print(obj)`    |
| **Fallback**        | Always available             | Falls back to `__repr__`      |
| **Format**          | Detailed and unambiguous     | Simplified and readable       |

---

## 3. **Defining `__repr__` and `__str__`**

### Example:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

    def __str__(self):
        return f"{self.name}, {self.age} years old"

person = Person("Alice", 30)
print(repr(person))  # Output: Person(name='Alice', age=30)
print(str(person))   # Output: Alice, 30 years old
```

---

## 4. **`__repr__` and Debugging**

The `__repr__` method is essential for debugging because it provides detailed and reproducible information about the object.

### Example:
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

point = Point(3, 5)
print(repr(point))  # Output: Point(x=3, y=5)
```

---

## 5. **`__str__` for User-Friendly Output**

The `__str__` method provides a readable representation that is useful for end-users.

### Example:
```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def __str__(self):
        return f"Product: {self.name}, Price: ${self.price:.2f}"

product = Product("Laptop", 999.99)
print(product)  # Output: Product: Laptop, Price: $999.99
```

---

## 6. **Fallback Behavior**

If `__str__` is not defined, Python falls back to `__repr__`. If neither is defined, Python uses the default implementation from the base `object` class, which returns a string containing the object’s memory address.

### Example:
```python
class DefaultExample:
    pass

obj = DefaultExample()
print(repr(obj))  # Output: <__main__.DefaultExample object at 0x...>
print(str(obj))   # Output: <__main__.DefaultExample object at 0x...>
```

---

## 7. **Best Practices for `__repr__` and `__str__`**

1. **Make `__repr__` Unambiguous:**
   - Ensure that `__repr__` provides all necessary details to recreate the object.

2. **Make `__str__` Readable:**
   - Focus on user-friendly formatting for `__str__`.

3. **Fallback to `__repr__` When Appropriate:**
   - If the object doesn’t require a user-friendly string representation, you can skip defining `__str__`.

4. **Use f-strings for Formatting:**
   - Python’s f-strings simplify the creation of readable string representations.

5. **Be Consistent:**
   - Ensure that `__str__` and `__repr__` are aligned with the purpose and audience of your application.

---

## 8. **Examples of `__repr__` and `__str__` in Built-In Types**

### Example 1: Lists
```python
lst = [1, 2, 3]
print(repr(lst))  # Output: [1, 2, 3]
print(str(lst))   # Output: [1, 2, 3]
```

### Example 2: Datetime
```python
from datetime import datetime
now = datetime.now()
print(repr(now))  # Output: datetime.datetime(YYYY, MM, DD, HH, MM, SS, ...)
print(str(now))   # Output: YYYY-MM-DD HH:MM:SS
```

---

## 9. **When to Use Each Method**

| **Scenario**            | **Method to Implement** |
|--------------------------|--------------------------|
| Debugging/Logging        | `__repr__`              |
| User Interaction/Output  | `__str__`               |

---

## 10. **Conclusion**

The `__str__` and `__repr__` methods play a critical role in Python’s object-oriented design, enabling developers to define meaningful string representations for their objects. By using these methods effectively, you can enhance debugging, logging, and user-facing output, making your classes more intuitive and informative.

<a id='arithmetic'></a>
# Polymorphism in Arithmetic Operators in Python

Polymorphism allows arithmetic operators such as `+`, `-`, `*`, `/`, etc., to perform different operations depending on the types of operands involved. In Python, this concept is extended through operator overloading, where you can redefine the behavior of these operators for user-defined classes.

---

## 1. **Built-in Polymorphism in Arithmetic Operators**

### Key Characteristics:
1. Operators behave differently based on the types of operands.
2. This behavior is predefined for built-in types like integers, floats, strings, and lists.

### Examples:
#### Addition (`+`):
```python
# Integer addition
print(3 + 5)  # Output: 8

# String concatenation
print("Hello" + " World")  # Output: Hello World

# List concatenation
print([1, 2] + [3, 4])  # Output: [1, 2, 3, 4]
```

#### Multiplication (`*`):
```python
# Integer multiplication
print(3 * 4)  # Output: 12

# String repetition
print("A" * 3)  # Output: AAA

# List repetition
print([1, 2] * 2)  # Output: [1, 2, 1, 2]
```

---

## 2. **Operator Overloading for Custom Classes**

Python allows you to define how arithmetic operators behave for custom classes by implementing special methods like `__add__`, `__sub__`, `__mul__`, etc.

### Example:
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Output: Vector(4, 6)
print(v1 - v2)  # Output: Vector(-2, -2)
```

In this example:
- The `+` operator is overloaded via the `__add__` method.
- The `-` operator is overloaded via the `__sub__` method.

---

## 3. **Supported Special Methods for Arithmetic Operators**

| Operator | Special Method   | Example Usage             |
|----------|------------------|---------------------------|
| `+`      | `__add__`        | `a + b`                  |
| `-`      | `__sub__`        | `a - b`                  |
| `*`      | `__mul__`        | `a * b`                  |
| `/`      | `__truediv__`    | `a / b`                  |
| `//`     | `__floordiv__`   | `a // b`                 |
| `%`      | `__mod__`        | `a % b`                  |
| `**`     | `__pow__`        | `a ** b`                 |
| `@`      | `__matmul__`     | `a @ b` (Matrix multiplication) |

---

## 4. **Using Polymorphism for Advanced Arithmetic Operations**

You can extend the behavior of operators to create custom mathematical or domain-specific operations.

### Example: Complex Numbers
```python
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        return ComplexNumber(self.real + other.real, self.imag + other.imag)

    def __mul__(self, other):
        real = self.real * other.real - self.imag * other.imag
        imag = self.real * other.imag + self.imag * other.real
        return ComplexNumber(real, imag)

    def __repr__(self):
        return f"({self.real} + {self.imag}i)"

c1 = ComplexNumber(1, 2)
c2 = ComplexNumber(3, 4)
print(c1 + c2)  # Output: (4 + 6i)
print(c1 * c2)  # Output: (-5 + 10i)
```

---

## 5. **Best Practices for Operator Overloading**

1. **Use Intuitively:**
   - Ensure the overloaded operators behave in ways consistent with their typical use.

2. **Keep it Simple:**
   - Avoid overloading operators in ways that introduce unnecessary complexity or confusion.

3. **Document Behavior:**
   - Clearly document what the overloaded operators do to help other developers understand your code.

4. **Ensure Compatibility:**
   - When overloading, ensure that the behavior works with operands of the same type and possibly with other types if needed.

---

## 6. **Common Pitfalls**

1. **Overcomplicating Logic:**
   - Avoid cramming too much logic into operator methods.

2. **Ignoring Type Checking:**
   - Ensure your operators handle incompatible types gracefully.

3. **Unintuitive Behavior:**
   - Overloading operators to perform tasks unrelated to their typical usage can confuse users.

---

## 7. **Conclusion**

Polymorphism in arithmetic operators allows you to redefine their behavior for user-defined classes, making your objects intuitive and expressive. By leveraging operator overloading responsibly, you can create more natural interfaces for mathematical, geometric, or domain-specific computations while ensuring code readability and maintainability.

<a id='rich-comparisons'></a>
# Rich Comparisons in Python

Rich comparisons in Python allow you to define custom behaviors for comparison operators such as `<`, `>`, `<=`, `>=`, `==`, and `!=`. This is achieved through special methods that can be implemented in your classes to handle comparison logic between objects.

---

## 1. **What are Rich Comparisons?**

### Key Features:
1. **Custom Behavior:**
   - Define how objects are compared using special methods.
2. **Supported Operators:**
   - Rich comparisons cover `<`, `>`, `<=`, `>=`, `==`, and `!=`.
3. **Enhanced Flexibility:**
   - Comparison behavior can depend on object attributes, types, or custom logic.

### Example:
```python
class Box:
    def __init__(self, weight):
        self.weight = weight

    def __lt__(self, other):  # Less than
        return self.weight < other.weight

    def __eq__(self, other):  # Equal to
        return self.weight == other.weight

box1 = Box(10)
box2 = Box(20)
print(box1 < box2)  # Output: True
print(box1 == box2)  # Output: False
```

---

## 2. **Special Methods for Rich Comparisons**

| Operator | Special Method | Example Usage   |
|----------|----------------|-----------------|
| `<`      | `__lt__`       | `a < b`         |
| `<=`     | `__le__`       | `a <= b`        |
| `>`      | `__gt__`       | `a > b`         |
| `>=`     | `__ge__`       | `a >= b`        |
| `==`     | `__eq__`       | `a == b`        |
| `!=`     | `__ne__`       | `a != b`        |

Each method should return `True` or `False` based on the comparison logic.

---

## 3. **Implementing All Comparison Operators**

You can define all six comparison operators in a class to fully customize its comparison behavior.

### Example:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age

    def __ne__(self, other):
        return self.age != other.age

    def __lt__(self, other):
        return self.age < other.age

    def __le__(self, other):
        return self.age <= other.age

    def __gt__(self, other):
        return self.age > other.age

    def __ge__(self, other):
        return self.age >= other.age

person1 = Person("Alice", 30)
person2 = Person("Bob", 25)
print(person1 > person2)  # Output: True
print(person1 == person2)  # Output: False
```

---

## 4. **Best Practices for Rich Comparisons**

1. **Implement `__eq__` and `__ne__` Together:**
   - Ensure consistency between equality (`==`) and inequality (`!=`) operations.
2. **Ensure Logical Consistency:**
   - Comparisons should be intuitive and transitive. For example, if `a < b` and `b < c`, then `a < c` should be `True`.
3. **Fallback to Default Behavior When Needed:**
   - If a method is not implemented, Python may raise a `TypeError`. Implement only the comparisons your class needs.
4. **Optimize Performance:**
   - Avoid expensive calculations in comparison methods.

---

## 5. **Real-World Applications**

### 5.1 Sorting Objects:
Rich comparisons enable custom sorting of objects.
```python
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade

    def __lt__(self, other):
        return self.grade < other.grade

students = [Student("Alice", 85), Student("Bob", 90), Student("Charlie", 80)]
students.sort()
for student in students:
    print(student.name, student.grade)
# Output:
# Charlie 80
# Alice 85
# Bob 90
```

### 5.2 Filtering and Comparison:
```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def __gt__(self, other):
        return self.price > other.price

products = [Product("A", 100), Product("B", 50), Product("C", 150)]
expensive = [p for p in products if p > Product("Threshold", 75)]
for product in expensive:
    print(product.name, product.price)
# Output:
# A 100
# C 150
```

---

## 6. **Common Pitfalls**

1. **Overcomplicating Logic:**
   - Keep comparison methods simple and intuitive.

2. **Ignoring Type Checking:**
   - Ensure the `other` operand is of a compatible type to avoid unexpected errors.

3. **Inconsistent Comparisons:**
   - Avoid scenarios where comparisons yield conflicting results.

### Example of Inconsistent Comparison:
```python
class Example:
    def __eq__(self, other):
        return True

    def __ne__(self, other):
        return True

obj = Example()
print(obj == obj)  # Output: True
print(obj != obj)  # Output: True (inconsistent!)
```

---

## 7. **Conclusion**

Rich comparisons in Python provide a flexible way to define custom comparison logic for user-defined classes. By implementing these methods effectively, you can enable intuitive, type-safe, and efficient comparison behavior that integrates seamlessly with Python’s built-in features like sorting and filtering. Always aim for consistency, clarity, and simplicity when defining rich comparisons.
<a id='hashing'></a>
# Hashing and Equality in Python

Hashing and equality in Python are tightly interconnected concepts that impact how objects are stored and retrieved in hash-based collections like dictionaries and sets. This document explores the relationship between hashing (`__hash__`) and equality (`__eq__`), their roles in Python, and best practices for implementing them.

---

## 1. **What is Hashing?**

Hashing is a process of converting an object into a fixed-size integer, known as its hash value. This value is used to quickly compare objects and determine their locations in hash-based collections like dictionaries and sets.

### Key Features:
- Hash values are computed using the `__hash__` method.
- Objects that are equal (as defined by `__eq__`) must have the same hash value.
- Hashable objects must be immutable.

### Example:
```python
print(hash("hello"))  # Hash value of a string
print(hash(42))        # Hash value of an integer
```

---

## 2. **What is Equality?**

Equality defines whether two objects are considered "equal." In Python, equality is determined by the `__eq__` method.

### Key Features:
- Equality is used to compare the values of objects.
- By default, `__eq__` checks for identity (`is`) unless explicitly overridden.

### Example:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.name == other.name and self.age == other.age

p1 = Person("Alice", 30)
p2 = Person("Alice", 30)
print(p1 == p2)  # Output: True
```

---

## 3. **Relationship Between `__hash__` and `__eq__`**

### Key Rules:
1. **Consistency:**
   - If two objects are equal (`__eq__` returns `True`), their hash values must be the same.
   - This ensures proper behavior in hash-based collections.

2. **Immutable Hashing:**
   - Objects that override `__hash__` and `__eq__` should be immutable to prevent hash inconsistencies.

3. **Default Behavior:**
   - If `__hash__` is not explicitly defined, Python uses the default implementation provided by the `object` class.

---

## 4. **Implementing `__hash__` and `__eq__`**

### Example:
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        return hash((self.x, self.y))

p1 = Point(1, 2)
p2 = Point(1, 2)
print(p1 == p2)  # Output: True
print(hash(p1))  # Output: Hash value
print(hash(p2))  # Output: Same hash value as p1
```

In this example:
- `__eq__` checks whether the coordinates of two `Point` objects are the same.
- `__hash__` generates a hash value based on the coordinates.

---

## 5. **Hashability of Built-In Types**

### Hashable:
- `int`, `float`, `str`, `tuple` (if elements are hashable)
- Examples:
  ```python
  print(hash(42))         # Hashable integer
  print(hash("hello"))    # Hashable string
  print(hash((1, 2, 3)))  # Hashable tuple
  ```

### Unhashable:
- `list`, `dict`, `set`
- Examples:
  ```python
  # print(hash([1, 2, 3]))  # Raises TypeError: unhashable type: 'list'
  ```

---

## 6. **Best Practices for `__hash__` and `__eq__`**

1. **Consistency Between `__hash__` and `__eq__`:**
   - Always ensure that objects considered equal have the same hash value.

2. **Use Immutable Data:**
   - Base your hash value computation on immutable attributes to avoid inconsistencies.

3. **Combine Attributes for Hashing:**
   - Use tuples of attributes to compute the hash value for better distribution.
   ```python
   def __hash__(self):
       return hash((self.attr1, self.attr2))
   ```

4. **Default Implementation:**
   - If you override `__eq__`, you should also override `__hash__` to maintain consistency.

5. **Avoid Mutable Objects in Hashing:**
   - Hash values of mutable objects can lead to undefined behavior in hash-based collections.

---

## 7. **Common Pitfalls**

### Inconsistent `__eq__` and `__hash__`
```python
class Example:
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return self.value == other.value

    # Missing __hash__ implementation

obj1 = Example(1)
obj2 = Example(1)
print(hash(obj1))  # Output: Raises TypeError
```

### Using Mutable Attributes for Hashing
```python
class MutableExample:
    def __init__(self, items):
        self.items = items

    def __hash__(self):
        return hash(tuple(self.items))

mutable_obj = MutableExample([1, 2, 3])
mutable_obj.items.append(4)  # Mutates the object
print(hash(mutable_obj))  # Undefined behavior
```

---

## 8. **Conclusion**

Understanding and correctly implementing `__hash__` and `__eq__` is critical for creating hashable objects in Python. These methods determine how objects are compared and stored in hash-based collections like dictionaries and sets. By following best practices and ensuring consistency, you can create robust and predictable behavior for your custom classes.
<a id='booleans'></a>
# Polymorphism and Boolean Evaluation in Python

Polymorphism in Python extends to the way objects are evaluated in Boolean contexts. Python's object model allows you to control how instances of user-defined classes are interpreted as `True` or `False` through the implementation of specific magic methods. This document explores Boolean polymorphism in Python, its default behavior, and how to customize it.

---

## 1. **Boolean Contexts in Python**

In Python, objects are evaluated in Boolean contexts such as:
- Conditional statements (`if`, `while`).
- Logical operations (`and`, `or`, `not`).

### Default Rules:
1. Objects are considered `True` unless explicitly defined as `False`.
2. The following are always considered `False`:
   - `None`
   - `False`
   - Zero of any numeric type (e.g., `0`, `0.0`).
   - Empty collections (`[]`, `{}`, `set()`, `""`).

### Example:
```python
if []:
    print("True")
else:
    print("False")  # Output: False
```

---

## 2. **Controlling Boolean Evaluation with `__bool__`**

The `__bool__` method allows custom objects to define their truth value.

### Example:
```python
class MyObject:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        return bool(self.value)

obj = MyObject(0)
print(bool(obj))  # Output: False

obj = MyObject(42)
print(bool(obj))  # Output: True
```

---

## 3. **Using `__len__` for Boolean Evaluation**

If `__bool__` is not defined, Python falls back to the `__len__` method to determine an object's truth value. An object is considered `True` if its length is non-zero.

### Example:
```python
class MyCollection:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

collection = MyCollection([])
print(bool(collection))  # Output: False

collection = MyCollection([1, 2, 3])
print(bool(collection))  # Output: True
```

---

## 4. **Polymorphism in Boolean Evaluation**

Boolean evaluation in Python exhibits polymorphism because different object types can define their own rules for truthiness by overriding `__bool__` or `__len__`.

### Example:
```python
class AlwaysTrue:
    def __bool__(self):
        return True

class AlwaysFalse:
    def __bool__(self):
        return False

print(bool(AlwaysTrue()))  # Output: True
print(bool(AlwaysFalse()))  # Output: False
```

---

## 5. **Practical Applications of Boolean Polymorphism**

### 5.1 Lazy Evaluation:
Custom objects can represent computations that are only performed when needed.
```python
class LazyEvaluator:
    def __init__(self, func):
        self.func = func
        self._evaluated = None

    def __bool__(self):
        if self._evaluated is None:
            self._evaluated = self.func()
        return bool(self._evaluated)

obj = LazyEvaluator(lambda: 5 > 3)
print(bool(obj))  # Output: True
```

### 5.2 Resource Management:
Objects can define truthiness based on the availability of resources.
```python
class Resource:
    def __init__(self, available):
        self.available = available

    def __bool__(self):
        return self.available

resource = Resource(False)
if resource:
    print("Resource available")
else:
    print("Resource unavailable")  # Output: Resource unavailable
```

---

## 6. **Best Practices for Boolean Polymorphism**

1. **Keep Logic Simple:**
   - Ensure `__bool__` and `__len__` methods are intuitive and easy to understand.

2. **Align with Expectations:**
   - Make the truthiness of objects consistent with their real-world meaning.

3. **Avoid Ambiguity:**
   - Avoid implementing both `__bool__` and `__len__` in ways that conflict with each other.

4. **Fallback to Built-in Behavior:**
   - Use `bool()` and `len()` to determine truthiness when appropriate.

---

## 7. **Common Pitfalls**

### Overcomplicating Truth Logic:
Defining complex or counterintuitive logic in `__bool__` can lead to confusing behavior.
```python
class Confusing:
    def __bool__(self):
        return "unexpected truth value"

# Raises TypeError: __bool__ should return bool, not str
```

### Conflicting Implementations:
```python
class Conflicting:
    def __bool__(self):
        return True

    def __len__(self):
        return 0

obj = Conflicting()
print(bool(obj))  # Output: True (but len() suggests False)
```

---

## 8. **Conclusion**

Boolean polymorphism in Python provides powerful mechanisms to define how objects are evaluated in Boolean contexts. By leveraging `__bool__` and `__len__`, you can make your custom classes behave intuitively and integrate seamlessly with Python’s control flow. However, it is essential to design these methods with clarity and consistency to avoid confusing or unexpected behavior.

<a id='callables'></a>
# Polymorphism and Callables in Python

Polymorphism in Python extends to objects that can behave as functions. Callables are objects that can be invoked like functions using the `()` syntax. Python allows developers to create custom callable objects by implementing the `__call__` method in their classes.

---

## 1. **What are Callables?**

In Python, a callable is any object that can be invoked using parentheses `()`. This includes:
- Functions
- Methods
- Classes (when creating instances)
- Objects implementing the `__call__` method

### Example:
```python
# Built-in function
print(callable(len))  # Output: True

# Custom object
class MyCallable:
    def __call__(self):
        return "I am callable!"

obj = MyCallable()
print(callable(obj))  # Output: True
print(obj())          # Output: I am callable!
```

---

## 2. **The `__call__` Method**

The `__call__` method allows instances of a class to be invoked like functions. This makes the object callable and allows you to define custom behavior for function calls.

### Example:
```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, value):
        return value * self.factor

multiplier = Multiplier(3)
print(multiplier(5))  # Output: 15
```

In this example, `Multiplier` objects can be called like functions to multiply a value by a predefined factor.

---

## 3. **Polymorphism in Callables**

Polymorphism allows different callable objects to exhibit unique behavior while being used in a uniform way. This makes callables highly versatile in scenarios like callbacks, factories, and decorators.

### Example:
```python
class Adder:
    def __init__(self, increment):
        self.increment = increment

    def __call__(self, value):
        return value + self.increment

class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, value):
        return value * self.factor

# Uniform interface
callables = [Adder(10), Multiplier(2)]
for func in callables:
    print(func(5))
# Output:
# 15
# 10
```

---

## 4. **Using Callables in Practical Applications**

### 4.1 Function Factories:
Callables can be used to create dynamic functions or behaviors.
```python
class Power:
    def __init__(self, exponent):
        self.exponent = exponent

    def __call__(self, base):
        return base ** self.exponent

square = Power(2)
cube = Power(3)
print(square(4))  # Output: 16
print(cube(2))    # Output: 8
```

### 4.2 Stateful Callables:
Callables can maintain internal state between invocations.
```python
class Counter:
    def __init__(self):
        self.count = 0

    def __call__(self):
        self.count += 1
        return self.count

counter = Counter()
print(counter())  # Output: 1
print(counter())  # Output: 2
```

### 4.3 Callables as Callbacks:
Custom callable objects can be passed as callbacks to functions or libraries.
```python
class Logger:
    def __call__(self, message):
        print(f"LOG: {message}")

logger = Logger()
logger("This is a log message.")
```

---

## 5. **Checking for Callables**

You can check if an object is callable using the built-in `callable()` function.

### Example:
```python
print(callable(len))        # Output: True
print(callable(lambda x: x))  # Output: True

class NonCallable:
    pass

print(callable(NonCallable))  # Output: False
```

---

## 6. **Best Practices for Callable Objects**

1. **Use Intuitively:**
   - Ensure the callable behavior aligns with the object's purpose.

2. **Avoid Overcomplication:**
   - Keep the `__call__` method simple and focused.

3. **Document Callable Behavior:**
   - Clearly document what the callable object does when invoked.

4. **Leverage Polymorphism:**
   - Use callable objects to create interchangeable components that share a common interface.

---

## 7. **Common Pitfalls**

1. **Ambiguous Callables:**
   - Avoid creating callables that perform unrelated tasks, as this can confuse users.

2. **Overusing Stateful Callables:**
   - Use stateful callables judiciously to prevent unexpected behavior.

3. **Neglecting `callable()` Check:**
   - Always verify that an object is callable before invoking it.

---

## 8. **Conclusion**

Polymorphism with callables allows developers to create flexible, reusable, and dynamic objects that behave like functions. By implementing the `__call__` method, you can create objects that seamlessly integrate into Python's functional programming paradigm. When used effectively, callables can simplify code, enhance readability, and improve modularity in your applications.
<a id='del'></a>
# Polymorphism and the `__del__` Method in Python

The `__del__` method in Python is a special method used to define cleanup actions when an object is destroyed. Although it is not commonly used, the `__del__` method can be customized to exhibit polymorphic behavior, allowing different types of objects to implement their own cleanup logic.

---

## 1. **What is the `__del__` Method?**

### Key Features:
- The `__del__` method is called when an object is garbage collected.
- It allows for resource cleanup, such as closing files or releasing external resources.
- It is automatically invoked by Python’s garbage collector.

### Syntax:
```python
class ClassName:
    def __del__(self):
        # Cleanup code
        pass
```

### Example:
```python
class MyClass:
    def __del__(self):
        print("Object is being deleted")

obj = MyClass()
del obj  # Output: Object is being deleted
```

---

## 2. **Polymorphism in `__del__`**

Polymorphism allows different classes to implement their own version of the `__del__` method, providing custom cleanup logic for various object types.

### Example:
```python
class FileHandler:
    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename, 'w')

    def __del__(self):
        print(f"Closing file: {self.filename}")
        self.file.close()

class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        print(f"Connecting to database: {self.db_name}")

    def __del__(self):
        print(f"Closing database connection: {self.db_name}")

# Using polymorphic `__del__`
file_handler = FileHandler("example.txt")
db_connection = DatabaseConnection("my_database")

del file_handler
# Output: Closing file: example.txt

del db_connection
# Output: Closing database connection: my_database
```

---

## 3. **Best Practices for Using `__del__`**

1. **Use for Resource Management:**
   - Only use `__del__` to clean up non-memory resources such as files, network connections, or database handles.

2. **Avoid Overcomplication:**
   - Keep the `__del__` method simple and focused on cleanup.

3. **Prefer Context Managers:**
   - Use context managers (`with` statement) for resource management instead of relying on `__del__`.

4. **Handle Exceptions Gracefully:**
   - Ensure that exceptions within `__del__` do not propagate and cause undefined behavior.

---

## 4. **Limitations of the `__del__` Method**

1. **Unpredictable Execution:**
   - The exact timing of `__del__` execution depends on Python’s garbage collector.

2. **Circular References:**
   - Objects involved in circular references may not have their `__del__` method called.

3. **Not Always Necessary:**
   - Often, explicit cleanup methods or context managers are preferred for managing resources.

---

## 5. **Using `weakref.finalize` as an Alternative**

The `weakref.finalize` function provides a more predictable way to define cleanup actions without overriding `__del__`.

### Example:
```python
import weakref

class Resource:
    def __init__(self, name):
        self.name = name
        print(f"Allocating resource: {self.name}")
        weakref.finalize(self, self.cleanup)

    def cleanup(self):
        print(f"Cleaning up resource: {self.name}")

res = Resource("Resource1")
# Output: Allocating resource: Resource1

# Cleanup is triggered when the object is garbage collected
```

---

## 6. **Common Pitfalls**

1. **Overusing `__del__`:**
   - Relying too much on `__del__` can lead to unpredictable behavior, especially in programs with complex lifecycles.

2. **Unmanaged Resources:**
   - Forgetting to implement proper cleanup logic can lead to resource leaks.

3. **Circular References:**
   - Objects in circular references may prevent `__del__` from being called unless explicitly handled.

---

## 7. **Conclusion**

The `__del__` method enables custom cleanup logic for Python objects, but it should be used judiciously. By leveraging polymorphism, different classes can implement tailored cleanup behaviors. However, due to the unpredictable nature of garbage collection, it is often better to use explicit cleanup methods or context managers to manage resources effectively.
<a id='format'></a>

# Polymorphism and the `format` Method in Python

The `format` method in Python is a powerful and flexible tool for string formatting. It exhibits polymorphism by allowing objects of different types to define their own formatting behavior through the `__format__` special method. This allows developers to create custom, type-specific formatting logic while maintaining a consistent interface.

---

## 1. **What is the `format` Method?**

The `format` method is used to interpolate variables or values into a string, providing flexibility in how data is displayed or represented.

### Syntax:
```python
string.format(*args, **kwargs)
```

### Example:
```python
name = "Alice"
age = 30

formatted = "My name is {} and I am {} years old.".format(name, age)
print(formatted)  # Output: My name is Alice and I am 30 years old.
```

---

## 2. **Polymorphism in the `format` Method**

Polymorphism in the `format` method is achieved via the `__format__` special method. Different object types can implement `__format__` to define their own formatting rules.

### Example:
```python
class CustomNumber:
    def __init__(self, value):
        self.value = value

    def __format__(self, format_spec):
        if format_spec == "hex":
            return hex(self.value)
        elif format_spec == "bin":
            return bin(self.value)
        else:
            return str(self.value)

num = CustomNumber(42)
print("Decimal: {:}".format(num))  # Output: Decimal: 42
print("Hex: {:hex}".format(num))  # Output: Hex: 0x2a
print("Binary: {:bin}".format(num))  # Output: Binary: 0b101010
```

---

## 3. **Defining `__format__` in Custom Classes**

The `__format__` method allows developers to define custom formatting behavior for their objects.

### Example:
```python
class Currency:
    def __init__(self, amount):
        self.amount = amount

    def __format__(self, format_spec):
        if format_spec == "usd":
            return f"${self.amount:.2f}"
        elif format_spec == "eur":
            return f"€{self.amount:.2f}"
        else:
            return f"{self.amount:.2f}"

price = Currency(19.99)
print("Price in USD: {:usd}".format(price))  # Output: Price in USD: $19.99
print("Price in EUR: {:eur}".format(price))  # Output: Price in EUR: €19.99
```

---

## 4. **Combining `__format__` with Built-In Types**

Built-in types like integers, floats, and dates already implement the `__format__` method, allowing for extensive customization.

### Example:
#### Integers:
```python
print("Binary: {:b}".format(42))  # Output: Binary: 101010
print("Hexadecimal: {:x}".format(255))  # Output: Hexadecimal: ff
```

#### Floats:
```python
print("Scientific: {:e}".format(12345.6789))  # Output: Scientific: 1.234568e+04
print("Percentage: {:.2%}".format(0.75))  # Output: Percentage: 75.00%
```

#### Dates:
```python
from datetime import datetime

date = datetime(2025, 1, 23, 12, 45, 30)
print("Date: {:%Y-%m-%d}".format(date))  # Output: Date: 2025-01-23
print("Time: {:%H:%M:%S}".format(date))  # Output: Time: 12:45:30
```

---

## 5. **Using `format_map` for Dictionaries**

The `format_map` method extends the polymorphic behavior of `format` by allowing dictionaries to directly provide values for placeholders.

### Example:
```python
info = {"name": "Alice", "age": 30}

formatted = "My name is {name} and I am {age} years old.".format_map(info)
print(formatted)  # Output: My name is Alice and I am 30 years old.
```

---

## 6. **Best Practices for Using `__format__`**

1. **Keep It Intuitive:**
   - Ensure that the formatting behavior matches the object’s real-world representation.

2. **Handle Unknown Formats Gracefully:**
   - Provide a fallback behavior for unsupported format specifiers.

3. **Document Format Specifiers:**
   - Clearly document the supported specifiers in your class for better usability.

4. **Leverage Built-In Types:**
   - Use `str.format` or `f-strings` to delegate part of the formatting logic.

---

## 7. **Common Pitfalls**

1. **Overcomplicating `__format__`:**
   - Avoid adding overly complex logic to the `__format__` method.

2. **Ignoring Unknown Format Specifiers:**
   - Ensure that unsupported format specifiers are handled properly, either by raising an error or falling back to a default representation.

3. **Not Supporting Default Behavior:**
   - Always provide a default representation for cases where no format specifier is provided.

---

## 8. **Conclusion**

The `format` method in Python demonstrates polymorphism by allowing objects to define their own formatting logic through the `__format__` method. By leveraging this feature, you can create custom, intuitive, and type-specific formatting rules for your classes while integrating seamlessly with Python’s string formatting capabilities. Properly implementing the `__format__` method enhances the usability and readability of your custom objects.
