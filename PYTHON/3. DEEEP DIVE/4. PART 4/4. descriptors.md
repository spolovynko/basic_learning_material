- [DESCRIPTORS](#descriptors)
- [GETTER AND SETTER](#getter-setter)
- [USING INSTANCE PROPERTIES](#instance-properties)
- [STRONG VS WEAK REEFERENCES](#strong-weak-references)
- [SET NAME METHOD](#__set_name__)
- [PROPERTY LOOKUP RESOLUTION](#property-lookup)
- [PROPERTIES AND DESCRIPTORS](#properties-and-descriptors)
- [FUNCTIONS AND DESCRIPTORS](#functions)

  
<a id='descriptors'></a>
# Descriptors in Python

Descriptors are a powerful feature in Python that enable custom behavior when accessing, modifying, or deleting attributes of an object. By defining specific methods, descriptors allow developers to intercept and control attribute access in a flexible and reusable way.

---

## 1. **What are Descriptors?**

A descriptor is any object that implements one or more of the following special methods:

- `__get__(self, instance, owner)`: Controls attribute retrieval.
- `__set__(self, instance, value)`: Controls attribute assignment.
- `__delete__(self, instance)`: Controls attribute deletion.

Descriptors are typically used in combination with classes to manage instance attributes in a controlled and reusable manner.

### Syntax:
```python
class Descriptor:
    def __get__(self, instance, owner):
        # Logic for retrieving the value

    def __set__(self, instance, value):
        # Logic for setting the value

    def __delete__(self, instance):
        # Logic for deleting the value
```

---

## 2. **Types of Descriptors**

### 2.1 Data Descriptors:
- Implement both `__get__` and `__set__` (or `__delete__`).
- Take precedence over instance dictionaries when accessing attributes.

### 2.2 Non-Data Descriptors:
- Implement only `__get__`.
- Allow instance attributes to override the descriptor.

### Example:
```python
class NonDataDescriptor:
    def __get__(self, instance, owner):
        return "Non-data descriptor access"

class DataDescriptor:
    def __get__(self, instance, owner):
        return "Data descriptor access"

    def __set__(self, instance, value):
        print(f"Setting value to {value}")

class Example:
    non_data = NonDataDescriptor()
    data = DataDescriptor()

obj = Example()
print(obj.non_data)  # Output: Non-data descriptor access
print(obj.data)      # Output: Data descriptor access
obj.data = 42        # Output: Setting value to 42
```

---

## 3. **How Descriptors Work**

Descriptors rely on the **descriptor protocol**, which is used internally by Python when attributes are accessed. Here’s the step-by-step process:

1. **Attribute Access (`obj.attr`)**:
   - If the attribute is managed by a descriptor (i.e., implements `__get__`), the `__get__` method is called.

2. **Attribute Assignment (`obj.attr = value`)**:
   - If the attribute is managed by a data descriptor (i.e., implements `__set__`), the `__set__` method is called.

3. **Attribute Deletion (`del obj.attr`)**:
   - If the attribute is managed by a descriptor (i.e., implements `__delete__`), the `__delete__` method is called.

---

## 4. **Practical Applications of Descriptors**

### 4.1 Validating Attributes:
Descriptors can enforce validation rules when setting attributes.

```python
class PositiveNumber:
    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("Value must be positive")
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name

class Account:
    balance = PositiveNumber()

account = Account()
account.balance = 100
print(account.balance)  # Output: 100

account.balance = -50   # Raises ValueError: Value must be positive
```

### 4.2 Lazy Attribute Evaluation:
Descriptors can delay attribute evaluation until the first access (useful for expensive computations).

```python
class LazyAttribute:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self.func(instance)
        instance.__dict__[self.func.__name__] = value
        return value

class Circle:
    def __init__(self, radius):
        self.radius = radius

    @LazyAttribute
    def area(self):
        print("Calculating area...")
        return 3.14 * self.radius ** 2

circle = Circle(5)
print(circle.area)  # Output: Calculating area... 78.5
print(circle.area)  # Output: 78.5 (cached value)
```

---

## 5. **Advantages of Descriptors**

1. **Reusability:**
   - Descriptors encapsulate attribute management logic that can be reused across multiple classes.

2. **Encapsulation:**
   - Keep attribute management logic separate from the primary class logic.

3. **Custom Behavior:**
   - Enable custom behavior for attribute access, assignment, and deletion.

4. **Memory Efficiency:**
   - Descriptors can reduce memory usage by avoiding `__dict__` storage for attributes.

---

## 6. **Common Pitfalls**

1. **Overcomplicating Attribute Management:**
   - Avoid using descriptors for simple attribute access unless necessary.

2. **Unintended Overwrites:**
   - Be careful with instance attributes that can override non-data descriptors.

3. **Debugging Complexity:**
   - Debugging descriptor-related issues can be challenging due to the indirection introduced by `__get__`, `__set__`, and `__delete__`.

---

## 7. **Best Practices**

1. **Use `__set_name__` for Automatic Naming:**
   - The `__set_name__` method simplifies assigning names to descriptors when they are declared in a class.

2. **Keep Logic Simple:**
   - Use descriptors for well-defined, reusable attribute management tasks like validation, caching, or lazy evaluation.

3. **Document Descriptor Behavior:**
   - Clearly explain the behavior and purpose of custom descriptors in the code documentation.

---

## 8. **Conclusion**

Descriptors in Python provide a robust mechanism for customizing and controlling attribute behavior. They are particularly useful for tasks like validation, lazy evaluation, caching, and reusable logic. However, they should be used judiciously to avoid unnecessary complexity and ensure maintainability.

<a id='getter-setter'></a>
# Getters and Setters in Python

Getters and setters are methods that allow controlled access to an object's attributes. They provide a way to implement encapsulation, which is a fundamental principle of object-oriented programming (OOP). In Python, getters and setters can be implemented using conventional methods or with the `property()` function and the `@property` decorator.

---

## 1. **What are Getters and Setters?**

### Key Features:
1. **Encapsulation:**
   - Control access to attributes, preventing unauthorized modifications.
2. **Validation:**
   - Ensure that attributes hold valid data by performing checks in setters.
3. **Custom Logic:**
   - Add custom behavior when retrieving or modifying attributes.

---

## 2. **Implementing Getters and Setters**

### 2.1 Using Methods:
The simplest way to implement getters and setters is by using methods.

```python
class Person:
    def __init__(self, name):
        self._name = name  # Use a private attribute

    def get_name(self):
        return self._name

    def set_name(self, value):
        if not isinstance(value, str):
            raise ValueError("Name must be a string")
        self._name = value

# Usage
person = Person("Alice")
print(person.get_name())  # Output: Alice
person.set_name("Bob")
print(person.get_name())  # Output: Bob
```

### 2.2 Using the `property()` Function:
The `property()` function creates property objects that link getter, setter, and deleter methods to an attribute.

```python
class Person:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, value):
        if not isinstance(value, str):
            raise ValueError("Name must be a string")
        self._name = value

    name = property(get_name, set_name)

# Usage
person = Person("Alice")
print(person.name)  # Output: Alice
person.name = "Bob"
print(person.name)  # Output: Bob
```

---

## 3. **Using the `@property` Decorator**

Python simplifies the creation of getters and setters with the `@property` decorator. This approach improves readability and avoids explicitly calling the `property()` function.

### Example:
```python
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        """Getter for name"""
        return self._name

    @name.setter
    def name(self, value):
        """Setter for name"""
        if not isinstance(value, str):
            raise ValueError("Name must be a string")
        self._name = value

# Usage
person = Person("Alice")
print(person.name)  # Output: Alice
person.name = "Bob"
print(person.name)  # Output: Bob
```

---

## 4. **Advantages of Getters and Setters**

1. **Encapsulation:**
   - Prevents direct access to attributes, allowing controlled manipulation.

2. **Validation:**
   - Ensures attributes hold valid values by adding checks in setters.

3. **Custom Behavior:**
   - Add logging, caching, or other behaviors during attribute access or modification.

4. **Future-Proofing:**
   - Allows changes to internal implementation without affecting the interface.

---

## 5. **Best Practices**

1. **Use Private Attributes:**
   - Use a single underscore (e.g., `_attribute`) to indicate that an attribute is intended to be private.

2. **Minimize Overuse:**
   - Avoid using getters and setters for every attribute. Use them only when additional logic is needed.

3. **Leverage `@property`:**
   - Prefer the `@property` decorator for cleaner and more Pythonic code.

4. **Document Accessors:**
   - Clearly document the purpose of your getters and setters.

---

## 6. **Common Pitfalls**

1. **Unnecessary Complexity:**
   - Avoid creating getters and setters for attributes that do not require validation or custom behavior.

2. **Performance Overhead:**
   - Adding complex logic in getters and setters can introduce performance bottlenecks.

3. **Inconsistent Behavior:**
   - Ensure that the getter and setter for an attribute behave consistently.

---

## 7. **Conclusion**

Getters and setters in Python provide a controlled and extensible way to manage attribute access in a class. Whether implemented using conventional methods, `property()`, or the `@property` decorator, they enhance encapsulation, validation, and maintainability. By following best practices, you can ensure clean, Pythonic, and future-proof code.

<a id='instance-properties'></a>
# Using Instance Properties in the Scope of Descriptors

## Introduction to Descriptors

Descriptors are a powerful feature of Python, enabling custom behavior for attribute access. A descriptor is a class that implements one or more of the following special methods:

- `__get__(self, instance, owner)` - Defines behavior for retrieving an attribute value.
- `__set__(self, instance, value)` - Defines behavior for setting an attribute value.
- `__delete__(self, instance)` - Defines behavior for deleting an attribute.

Descriptors are often used to manage access, validate data, or create computed properties.

## Instance Properties

Instance properties are attributes specific to an instance of a class, as opposed to class attributes, which are shared across all instances. In the context of descriptors, instance properties are typically used to store data relevant to a specific instance, often leveraging private attributes.

## Example: Using Instance Properties with Descriptors

Here is a step-by-step example to demonstrate how instance properties and descriptors can work together.

### Step 1: Define a Descriptor

The descriptor will define how to manage an attribute for the owning class:

```python
class PositiveNumber:
    def __init__(self, name):
        self.name = name  # Store the name of the attribute

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name, 0)  # Retrieve the instance-specific value

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError(f"{self.name} must be a positive number")
        instance.__dict__[self.name] = value  # Store the value in the instance's __dict__

    def __delete__(self, instance):
        if self.name in instance.__dict__:
            del instance.__dict__[self.name]
```

### Step 2: Use the Descriptor in a Class

The descriptor is then used as a property within a class:

```python
class Product:
    price = PositiveNumber("price")  # Descriptor for the 'price' property

    def __init__(self, name, price):
        self.name = name  # Instance-specific property
        self.price = price  # Uses the descriptor for validation
```

### Step 3: Test the Implementation

Create instances of the `Product` class and observe how the descriptor manages the `price` attribute:

```python
# Create a product instance
item = Product("Laptop", 1000)
print(item.price)  # Accessing the 'price' property through the descriptor

# Update the price
item.price = 1200
print(item.price)

# Attempt to set an invalid price
try:
    item.price = -500
except ValueError as e:
    print(e)
```

### Output:
```
1000
1200
price must be a positive number
```

## Key Points

1. **Instance Storage**:
   - The `__dict__` attribute of an instance is used to store instance-specific properties.
   - The descriptor uses the `self.name` as a key to access and manage the property within `instance.__dict__`.

2. **Validation**:
   - Descriptors can enforce validation or transformation logic before setting a property value.

3. **Encapsulation**:
   - The descriptor pattern helps encapsulate and centralize logic for managing a property, ensuring consistency across all instances of a class.

4. **Flexibility**:
   - Descriptors can work with instance-specific data without needing additional boilerplate code in the owning class.

## Advanced Use Cases

- **Computed Properties**: Use descriptors to compute values dynamically based on other instance attributes.
- **Caching**: Store expensive-to-compute values in the instance's `__dict__` after the first computation.
- **Type Enforcement**: Ensure type consistency for specific attributes using descriptors.

### Example: Type Enforcement Descriptor

```python
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} must be of type {self.expected_type.__name__}")
        instance.__dict__[self.name] = value

class Person:
    name = Typed("name", str)
    age = Typed("age", int)

    def __init__(self, name, age):
        self.name = name
        self.age = age

# Testing type enforcement
person = Person("Alice", 30)
print(person.name, person.age)

try:
    person.age = "thirty"
except TypeError as e:
    print(e)
```

### Output:
```
Alice 30
age must be of type int
```

## Conclusion

Using instance properties in the scope of descriptors allows for fine-grained control and management of class attributes. Descriptors offer a clean and reusable way to enforce rules, validate data, and implement complex logic for properties, enhancing the robustness and maintainability of Python applications.

<a id='strong-weak-references'></a>
# Strong and Weak References in the Scope of Descriptors

## Introduction to References in Python

In Python, references are the way objects are accessed in memory. Two key types of references are:

1. **Strong References**: These references directly keep an object alive in memory. As long as a strong reference to an object exists, it won't be garbage collected.

2. **Weak References**: These references do not prevent an object from being garbage collected. Weak references are used when you need to refer to an object without impacting its lifecycle.

Descriptors often interact with references, especially when storing or managing object attributes. Using strong or weak references in descriptors can affect memory usage and object lifetimes.

---

## Understanding Strong References in Descriptors

Descriptors using strong references directly store objects, ensuring their lifetime is tied to the owning object. This is the default behavior when using `instance.__dict__` to store values.

### Example: Strong Reference in Descriptors

```python
class StrongDescriptor:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        if self.name in instance.__dict__:
            del instance.__dict__[self.name]

class Example:
    attr = StrongDescriptor("attr")

# Testing strong references
example = Example()
example.attr = "Strong Reference"
print(example.attr)  # Output: Strong Reference
```

In this example:
- The descriptor stores the attribute value in the instance's `__dict__`, maintaining a strong reference to it.
- The object will only be garbage collected when the owning object (`example`) is deleted.

---

## Weak References in Descriptors

Weak references allow you to refer to an object without preventing it from being garbage collected. This is useful when descriptors deal with large or temporary objects to prevent memory leaks.

### Using the `weakref` Module

Python provides the `weakref` module to create weak references.

### Example: Weak Reference in Descriptors

```python
import weakref

class WeakDescriptor:
    def __init__(self, name):
        self.name = name
        self.references = weakref.WeakKeyDictionary()  # Stores weak references

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return self.references.get(instance)

    def __set__(self, instance, value):
        self.references[instance] = value

    def __delete__(self, instance):
        if instance in self.references:
            del self.references[instance]

class Example:
    attr = WeakDescriptor("attr")

# Testing weak references
example = Example()
example.attr = "Weak Reference"
print(example.attr)  # Output: Weak Reference

# Delete the instance and check if the value is collected
del example
# The stored value will be garbage collected along with the instance.
```

### Explanation:
- The `WeakKeyDictionary` is used to associate instances with their attribute values via weak references.
- Once the `Example` object (`example`) is deleted, the attribute (`attr`) is also removed from memory.

---

## Strong vs Weak References in Descriptors

| **Aspect**            | **Strong References**                              | **Weak References**                                |
|-----------------------|---------------------------------------------------|--------------------------------------------------|
| **Memory Management** | Prevents garbage collection of the object.        | Allows garbage collection of the object.         |
| **Use Case**          | Persistent or critical data that must remain.     | Temporary or large objects to avoid memory leaks.|
| **Storage**           | Stored in `instance.__dict__`.                    | Stored in `weakref.WeakKeyDictionary`.           |
| **Garbage Collection**| Not eligible for collection while referenced.     | Collected when no strong references exist.       |

---

## Practical Applications

1. **Caching**: Use weak references to store temporary results in descriptors to avoid holding memory unnecessarily.
2. **Avoiding Circular References**: Weak references prevent circular dependencies that can complicate garbage collection.
3. **Large Objects**: When dealing with descriptors managing memory-intensive data like images or datasets, weak references reduce the risk of memory leaks.

### Example: Caching with Weak References

```python
class CachedDescriptor:
    def __init__(self, func):
        self.func = func
        self.cache = weakref.WeakKeyDictionary()

    def __get__(self, instance, owner):
        if instance is None:
            return self
        if instance not in self.cache:
            self.cache[instance] = self.func(instance)
        return self.cache[instance]

class Example:
    @CachedDescriptor
    def computed_value(self):
        print("Calculating...")
        return 42

# Testing caching
example = Example()
print(example.computed_value)  # Output: Calculating... \n 42
print(example.computed_value)  # Output: 42 (cached value)
```

---

## Conclusion

Strong and weak references each play a unique role in descriptors, balancing memory management and functionality:

- Use **strong references** for critical or persistent data that must remain accessible as long as the owning object exists.
- Use **weak references** to manage temporary or large data, ensuring efficient memory usage.

Understanding and leveraging these reference types in descriptors can lead to cleaner, more efficient, and more robust Python applications.

<a id='__set_name__'></a>
# The `__set_name__` Method in the Scope of Descriptors

## Introduction

The `__set_name__` method is a special method introduced in Python 3.6 that allows descriptors to dynamically receive the name of the attribute they are assigned to within the owning class. This method is particularly useful for simplifying descriptor implementations and ensuring consistency, especially when the attribute's name needs to be used internally by the descriptor.

The `__set_name__` method is called automatically when the descriptor is assigned as a class-level attribute in its owning class.

---

## Syntax of `__set_name__`

The `__set_name__` method has the following signature:

```python
class Descriptor:
    def __set_name__(self, owner, name):
        # Custom logic
```

### Parameters:
1. **`owner`**: The class in which the descriptor is defined.
2. **`name`**: The name of the attribute in the owner class to which the descriptor is assigned.

### Behavior:
- This method is called once, when the class is being created.
- It enables the descriptor to record the attribute name for later use, avoiding the need for manual assignment during initialization.

---

## Basic Example

Here is a simple example to demonstrate how the `__set_name__` method works:

```python
class Descriptor:
    def __set_name__(self, owner, name):
        self.name = name  # Save the attribute name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

class Example:
    attr = Descriptor()

# Testing the descriptor
example = Example()
example.attr = "Hello, __set_name__!"
print(example.attr)  # Output: Hello, __set_name__!
```

### Explanation:
1. The `Descriptor` class implements `__set_name__`, which captures the name of the attribute (`attr`) as defined in the `Example` class.
2. The `name` is stored in the descriptor, enabling it to access or manipulate the corresponding attribute dynamically.

---

## Practical Use Cases for `__set_name__`

### 1. Dynamic Attribute Tracking

The `__set_name__` method can be used to dynamically track attributes and their names:

```python
class TrackingDescriptor:
    def __set_name__(self, owner, name):
        self.name = name
        print(f"Attribute '{name}' initialized in {owner.__name__}")

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

class Example:
    attr1 = TrackingDescriptor()
    attr2 = TrackingDescriptor()

# Output:
# Attribute 'attr1' initialized in Example
# Attribute 'attr2' initialized in Example
```

### 2. Validation with Attribute Names

The `__set_name__` method can help implement validation logic based on attribute names:

```python
class ValidatingDescriptor:
    def __init__(self, expected_type):
        self.expected_type = expected_type

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} must be of type {self.expected_type.__name__}")
        instance.__dict__[self.name] = value

class Person:
    name = ValidatingDescriptor(str)
    age = ValidatingDescriptor(int)

# Testing validation
person = Person()
person.name = "Alice"  # Valid
person.age = 30  # Valid

try:
    person.age = "thirty"  # Invalid
except TypeError as e:
    print(e)  # Output: age must be of type int
```

### 3. Automatic Initialization of Related Attributes

The `__set_name__` method can initialize related attributes or metadata dynamically:

```python
class RelatedAttributeDescriptor:
    def __set_name__(self, owner, name):
        self.name = name
        self.related_name = f"_{name}_metadata"

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value
        instance.__dict__[self.related_name] = f"Metadata for {value}"

class Example:
    attr = RelatedAttributeDescriptor()

example = Example()
example.attr = "Data"
print(example.attr)  # Output: Data
print(example._attr_metadata)  # Output: Metadata for Data
```

---

## Key Benefits of `__set_name__`

1. **Automatic Attribute Name Registration**:
   - Avoids the need to pass the attribute name explicitly during descriptor initialization.

2. **Consistency Across Instances**:
   - Ensures consistent behavior by associating the attribute name with the descriptor dynamically.

3. **Enhanced Readability**:
   - Simplifies descriptor implementations, making the code cleaner and more intuitive.

4. **Flexibility**:
   - Enables advanced use cases like dynamic initialization, validation, and metadata management.

---

## Common Pitfalls

1. **Misuse of `__set_name__`**:
   - Ensure `__set_name__` is used only for defining class-level behavior, as it is called only during class creation.

2. **Accessing `self.name` Prematurely**:
   - Accessing `self.name` before `__set_name__` is called will raise an `AttributeError`.

---

## Conclusion

The `__set_name__` method is a crucial tool in the descriptor protocol, allowing descriptors to dynamically capture the attribute name they are bound to. It simplifies implementation, enhances flexibility, and opens the door to dynamic and reusable descriptor patterns. By leveraging `__set_name__`, developers can create more powerful and maintainable Python applications.
<a id='property-lookup'></a>
# Property Lookup Resolution in Python

## Introduction

Property lookup resolution refers to the process Python follows to determine the value associated with an attribute or property when it is accessed. Understanding this process is crucial for effectively designing classes, especially when using descriptors, properties, or inheritance.

This document explores the steps Python takes during property lookup, including the roles of `__dict__`, the class hierarchy, descriptors, and special methods like `__getattr__` and `__getattribute__`.

---

## Basics of Attribute Access

When an attribute is accessed, Python performs the following steps in order:

1. **Instance Attributes**:
   - Check if the attribute exists in the instance's `__dict__`.
   
2. **Class Descriptors**:
   - Look for descriptors in the class or its bases, checking for `__get__`, `__set__`, or `__delete__` methods.

3. **Class Attributes**:
   - Check if the attribute exists in the class's `__dict__`.

4. **Inheritance**:
   - Traverse the Method Resolution Order (MRO) to find the attribute in base classes.

5. **Special Methods**:
   - Call `__getattr__` or `__getattribute__` if the attribute is not found through the above steps.

---

## Descriptor Protocol in Property Lookup

Descriptors are objects that define custom behavior for attribute access. They implement one or more of the following methods:

- `__get__(self, instance, owner)`: Handles retrieval of the attribute.
- `__set__(self, instance, value)`: Handles setting of the attribute.
- `__delete__(self, instance)`: Handles deletion of the attribute.

### Types of Descriptors

1. **Data Descriptors**:
   - Implement both `__get__` and `__set__` (or `__delete__`).
   - Have higher priority during lookup.

2. **Non-Data Descriptors**:
   - Implement only `__get__`.
   - Have lower priority, checked after instance attributes.

### Example of Data and Non-Data Descriptors

```python
class DataDescriptor:
    def __get__(self, instance, owner):
        return "Data Descriptor Value"

    def __set__(self, instance, value):
        print("Setting value in Data Descriptor")

class NonDataDescriptor:
    def __get__(self, instance, owner):
        return "Non-Data Descriptor Value"

class Example:
    data = DataDescriptor()
    non_data = NonDataDescriptor()

example = Example()

# Accessing attributes
print(example.data)  # Output: Data Descriptor Value
print(example.non_data)  # Output: Non-Data Descriptor Value
```

---

## Property Lookup Resolution Steps

### 1. Instance Dictionary (`__dict__`)

Python first checks the instance's `__dict__` for the requested attribute. This step bypasses descriptors unless the attribute is explicitly defined as such.

```python
class Example:
    def __init__(self):
        self.attr = "Instance Value"

example = Example()
print(example.attr)  # Output: Instance Value
```

### 2. Data Descriptors

If the attribute is not found in `__dict__`, Python checks for a data descriptor in the class or its bases. Data descriptors have priority over instance attributes.

```python
class Descriptor:
    def __get__(self, instance, owner):
        return "Descriptor Value"

    def __set__(self, instance, value):
        instance.__dict__["attr"] = value

class Example:
    attr = Descriptor()

example = Example()
example.attr = "Instance Value"
print(example.attr)  # Output: Descriptor Value
```

### 3. Instance Attributes (if no Data Descriptor)

If no data descriptor is found, Python falls back to the instance’s `__dict__`.

```python
class Descriptor:
    def __get__(self, instance, owner):
        return "Descriptor Value"

class Example:
    attr = Descriptor()

example = Example()
example.__dict__["attr"] = "Instance Value"
print(example.attr)  # Output: Descriptor Value (due to the descriptor)
```

### 4. Non-Data Descriptors

If no data descriptor or instance attribute is found, Python checks for a non-data descriptor.

```python
class NonDataDescriptor:
    def __get__(self, instance, owner):
        return "Non-Data Descriptor Value"

class Example:
    attr = NonDataDescriptor()

example = Example()
example.__dict__["attr"] = "Instance Value"
print(example.attr)  # Output: Instance Value
```

### 5. Class and Inherited Attributes

If no descriptor is found, Python checks the class's `__dict__`, followed by the `__dict__` of its base classes in the MRO.

```python
class Base:
    attr = "Base Class Value"

class Derived(Base):
    pass

example = Derived()
print(example.attr)  # Output: Base Class Value
```

### 6. `__getattr__` and `__getattribute__`

If all else fails:

- `__getattribute__` is called for every attribute access.
- If the attribute cannot be found, `__getattr__` is called.

```python
class Example:
    def __getattr__(self, name):
        return f"{name} not found"

example = Example()
print(example.attr)  # Output: attr not found
```

---

## Attribute Lookup Summary

| Step                     | Priority | Example                                |
|--------------------------|----------|----------------------------------------|
| Instance `__dict__`      | High     | `instance.attr`                        |
| Data Descriptor          | Higher   | `__get__` and `__set__` in descriptor |
| Instance Attributes      | Medium   | `instance.__dict__[attr]`              |
| Non-Data Descriptor      | Lower    | `__get__` only in descriptor          |
| Class and Base Classes   | Lowest   | Attributes in MRO                     |
| `__getattr__`/`__getattribute__` | Catch-all | Special methods                      |

---

## Conclusion

Property lookup resolution in Python follows a well-defined sequence, balancing flexibility and control. Understanding this process is critical for leveraging Python's powerful features like descriptors, inheritance, and custom attribute access. By mastering property lookup, developers can design efficient, robust, and maintainable object-oriented systems.
<a id='properties-and-descriptors'></a>
# Properties and Descriptors in Python

## Introduction

Properties and descriptors are two powerful tools in Python that enable developers to control attribute access, add logic to attribute operations, and create clean, reusable, and maintainable code. While properties provide a higher-level interface for attribute management, descriptors are the underlying mechanism that powers both properties and more advanced attribute control.

This document explores the differences, similarities, and use cases for properties and descriptors.

---

## Properties

### What are Properties?

Properties are a built-in Python feature that allows you to define methods to control attribute access and assignment while presenting them as regular attributes. Properties are created using the `@property` decorator or the `property()` function.

### Creating Properties

#### Using the `@property` Decorator

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """Getter for radius"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Setter for radius"""
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    @radius.deleter
    def radius(self):
        """Deleter for radius"""
        del self._radius

# Using the property
c = Circle(5)
print(c.radius)  # Output: 5
c.radius = 10    # Setter updates radius
print(c.radius)  # Output: 10
```

#### Using the `property()` Function

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    def get_radius(self):
        return self._radius

    def set_radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    def del_radius(self):
        del self._radius

    radius = property(get_radius, set_radius, del_radius, "Radius property")

# Using the property
c = Circle(5)
print(c.radius)  # Output: 5
c.radius = 10    # Setter updates radius
print(c.radius)  # Output: 10
```

### Key Points About Properties

1. **Encapsulation**:
   - Properties provide a way to control access and modifications to private attributes while maintaining an intuitive interface.

2. **Readability**:
   - Code using properties looks clean and Pythonic.

3. **Simple Use Case**:
   - Best for controlling a single attribute with straightforward logic.

---

## Descriptors

### What are Descriptors?

Descriptors are objects that define custom behavior for attribute access, assignment, and deletion. They are more flexible than properties and allow developers to share logic across multiple attributes and classes.

A descriptor is a class that implements one or more of the following methods:

- `__get__(self, instance, owner)` - Defines behavior for retrieving the attribute.
- `__set__(self, instance, value)` - Defines behavior for setting the attribute.
- `__delete__(self, instance)` - Defines behavior for deleting the attribute.

### Creating Descriptors

#### Basic Descriptor Example

```python
class Descriptor:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        print(f"Getting {self.name}")
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        print(f"Setting {self.name} to {value}")
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print(f"Deleting {self.name}")
        del instance.__dict__[self.name]

class Example:
    attr = Descriptor("attr")

# Using the descriptor
example = Example()
example.attr = 42    # Output: Setting attr to 42
print(example.attr)  # Output: Getting attr \n 42
del example.attr     # Output: Deleting attr
```

#### Data vs Non-Data Descriptors

1. **Data Descriptors**:
   - Implement both `__get__` and `__set__` (or `__delete__`).
   - Take precedence over instance attributes during attribute lookup.

2. **Non-Data Descriptors**:
   - Implement only `__get__`.
   - Checked after instance attributes during attribute lookup.

---

## Properties vs Descriptors

| **Aspect**          | **Properties**                           | **Descriptors**                              |
|---------------------|------------------------------------------|----------------------------------------------|
| **Definition**      | Built-in feature for controlling access. | Custom class implementing special methods.   |
| **Complexity**      | Simpler to implement using decorators.   | More flexible but requires more code.        |
| **Reusability**     | Specific to a single attribute.          | Can be shared across multiple attributes.    |
| **Use Cases**       | Single, simple attribute control.        | Advanced attribute management and sharing.   |
| **Underlying Mechanism** | Powered by descriptors internally.       | Core implementation of attribute control.    |

---

## When to Use Properties vs Descriptors

### Use Properties When:

1. You need to manage a single attribute with straightforward logic.
2. Encapsulation and simplicity are your primary goals.
3. The logic is not shared between multiple attributes or classes.

### Use Descriptors When:

1. You need advanced control over attributes.
2. You want to reuse logic across multiple attributes or classes.
3. You are implementing functionality like validation, type checking, or computed properties.

---

## Combining Properties and Descriptors

You can use descriptors internally within properties to achieve a balance of simplicity and reusability.

```python
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"{self.name} must be of type {self.expected_type.__name__}")
        instance.__dict__[self.name] = value

class Person:
    name = Typed("name", str)

    def __init__(self, name):
        self.name = name

# Testing the combination
p = Person("Alice")
print(p.name)  # Output: Alice

try:
    p.name = 42  # Raises TypeError
except TypeError as e:
    print(e)  # Output: name must be of type str
```

---

## Conclusion

Properties and descriptors are essential tools for attribute control in Python. While properties provide a simple and high-level interface, descriptors offer greater flexibility and reusability. Choosing between them depends on the complexity of the use case and the need for code reuse. By mastering both, you can create clean, efficient, and maintainable Python programs.
<a id='functions'></a>

# Functions and Descriptors in Python

## Introduction

Functions and descriptors in Python are closely related, as functions can themselves be descriptors when used in specific contexts. Understanding how functions behave as descriptors and how they interact with the descriptor protocol can enhance your ability to design and implement advanced object-oriented systems.

This document explores the connection between functions and descriptors, how functions inherently follow the descriptor protocol, and practical use cases.

---

## Functions as Descriptors

### The Descriptor Protocol Recap

The descriptor protocol consists of three special methods that define how an object handles attribute access:

- `__get__(self, instance, owner)` - Handles attribute access.
- `__set__(self, instance, value)` - Handles attribute assignment.
- `__delete__(self, instance)` - Handles attribute deletion.

Functions in Python implement the `__get__` method, making them non-data descriptors by default. This allows functions to be bound to instances or classes dynamically.

---

## Method Binding with `__get__`

When a function is defined in a class, it is treated as a descriptor. Upon attribute access, the function’s `__get__` method is called, returning a **bound method** or **unbound function** depending on the context.

### Example: Function as a Descriptor

```python
class Example:
    def method(self):
        print("Method called")

# Accessing the function
example = Example()
example.method()  # Output: Method called
```

### What Happens Internally?

1. When `example.method` is accessed, the function's `__get__` method is called.
2. The `__get__` method binds the function to the instance (`example`), creating a bound method.
3. The bound method is returned and can be called.

### Descriptor-Like Behavior

```python
class Example:
    def method(self):
        pass

print(Example.method.__get__)  # Output: <method-wrapper '__get__' of function object>
```

This shows that functions are inherently descriptors because they implement the `__get__` method.

---

## Static and Class Methods

Static methods and class methods modify the default descriptor behavior of functions. They use the descriptor protocol to alter how methods are accessed and bound.

### Static Methods

Static methods do not require a reference to the instance or class. They are implemented using the `staticmethod` class, which overrides the function's default `__get__` behavior.

```python
class Example:
    @staticmethod
    def static_method():
        print("Static method called")

Example.static_method()  # Output: Static method called
example = Example()
example.static_method()  # Output: Static method called
```

**Key Points:**
- The `staticmethod` descriptor returns the original function without binding it to any instance or class.

### Class Methods

Class methods receive the class as their first argument. They are implemented using the `classmethod` class, which modifies the function's `__get__` behavior to bind it to the class instead of an instance.

```python
class Example:
    @classmethod
    def class_method(cls):
        print(f"Class method called from {cls}")

Example.class_method()  # Output: Class method called from <class '__main__.Example'>
example = Example()
example.class_method()  # Output: Class method called from <class '__main__.Example'>
```

**Key Points:**
- The `classmethod` descriptor returns a bound method with the class as the first argument.

---

## Custom Descriptors with Functions

You can define your own descriptors that interact with functions, enhancing their behavior for specific use cases.

### Example: Logging Descriptor

```python
class LoggingDescriptor:
    def __get__(self, instance, owner):
        print(f"Accessing method for instance {instance}")
        return self.func.__get__(instance, owner)

    def __set_name__(self, owner, name):
        self.name = name

    def __init__(self, func):
        self.func = func

class Example:
    @LoggingDescriptor
    def method(self):
        print("Method called")

example = Example()
example.method()  # Output: Accessing method for instance <__main__.Example object>
                  #         Method called
```

### Explanation
1. The `LoggingDescriptor` wraps a function and intercepts its access.
2. The `__get__` method ensures the function is bound correctly while adding logging functionality.
3. This pattern can be extended for validation, caching, or other advanced behaviors.

---

## Method Resolution with Functions and Descriptors

When an attribute is accessed, Python uses the following resolution order for descriptors:

1. **Data Descriptors** (implement `__get__` and `__set__`): Checked first.
2. **Instance Attributes**: Checked next.
3. **Non-Data Descriptors** (implement `__get__` only): Checked last.

### Example: Interaction Between Descriptors and Functions

```python
class DataDescriptor:
    def __get__(self, instance, owner):
        return "Data Descriptor Value"

    def __set__(self, instance, value):
        print("Setting value in Data Descriptor")

class Example:
    data = DataDescriptor()

    def method(self):
        return "Method Value"

example = Example()
print(example.data)  # Output: Data Descriptor Value
print(example.method())  # Output: Method Value
```

### Key Points:
- The data descriptor (`data`) takes precedence over instance and non-data descriptors (like `method`).

---

## Combining Functions and Descriptors

Combining functions with custom descriptors allows for powerful patterns such as validation, caching, and delegation.

### Example: Cached Function Results

```python
class CachedFunction:
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __get__(self, instance, owner):
        def wrapper(*args):
            if args not in self.cache:
                self.cache[args] = self.func(instance, *args)
            return self.cache[args]
        return wrapper

class Example:
    @CachedFunction
    def compute(self, x):
        print(f"Computing for {x}")
        return x * x

example = Example()
print(example.compute(2))  # Output: Computing for 2 \n 4
print(example.compute(2))  # Output: 4 (cached result)
```

---

## Conclusion

Functions and descriptors are deeply intertwined in Python's object model. Functions implement the descriptor protocol to enable method binding, and descriptors provide a flexible framework for customizing attribute behavior. By understanding their relationship, you can design more powerful and reusable Python code.