- [METAPROGRAMMING](#metaprogramming)
- [NEW METHOD](#new)
- [HOW CLASSES ARE CREATED](#class-creation)
- [INHERETING FROM TYPE](#inheriting)
- [METACLASS](#metaclass)
- [CLASS DECORATORS](#class-decorators)
- [METACLASSES VS CLASSDECORATORS](#meta-vs-decorators)
- [METACLASS PARAMETERS](#parameters)
- [__PREPARE__ METHOD](#prepare)
- [ATTRIBUTE READ ACCESSORS](#read)
- [ATTRIBUTE WRITE ACCESSORS](#write)

<a id='metaprogramming'></a>
# Metaprogramming in Python

## Introduction

Metaprogramming refers to the practice of writing programs that can manipulate themselves or other programs as data. In Python, this is achieved through dynamic behavior such as modifying classes, creating new functions, or altering objects at runtime. Metaprogramming allows developers to write more flexible, reusable, and concise code by abstracting repetitive patterns and dynamically adapting to new requirements.

This document explores the key tools and concepts of metaprogramming in Python, including decorators, metaclasses, and the `exec()` and `eval()` functions.

---

## Tools for Metaprogramming

### 1. Functions as First-Class Objects

In Python, functions are first-class objects, meaning they can be assigned to variables, passed as arguments, and returned from other functions. This flexibility is foundational to metaprogramming.

#### Example:

```python
def greet(name):
    return f"Hello, {name}!"

say_hello = greet
print(say_hello("Alice"))  # Output: Hello, Alice!
```

### 2. Decorators

Decorators are a powerful feature for modifying or enhancing the behavior of functions or methods dynamically. They are higher-order functions that take a function as input and return a modified or wrapped version.

#### Example:

```python
def logging_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with arguments {args} and {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

@logging_decorator
def add(a, b):
    return a + b

add(3, 5)
# Output:
# Calling add with arguments (3, 5) and {}
# add returned 8
```

### 3. Introspection

Python provides built-in functions for introspection, allowing programs to examine objects, their attributes, and their types at runtime.

#### Example:

```python
x = [1, 2, 3]
print(type(x))  # Output: <class 'list'>
print(dir(x))   # Output: List of all attributes and methods of the list object
```

### 4. Dynamic Code Execution (`exec` and `eval`)

Python supports executing dynamically generated code using the `exec()` and `eval()` functions.

#### Example:

```python
code = "x = 5\ny = 10\nprint(x + y)"
exec(code)  # Output: 15

expression = "5 + 10"
result = eval(expression)
print(result)  # Output: 15
```

**Caution**: Be careful with `exec()` and `eval()`, as they can execute arbitrary and potentially harmful code.

---

## Metaclasses

Metaclasses are the "classes of classes." They define how classes behave, allowing you to customize class creation and behavior.

### Basic Metaclass Example

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass

# Output: Creating class MyClass
```

### Use Cases for Metaclasses

1. **Class Validation**: Enforce specific class-level constraints.
2. **Automatic Attribute Creation**: Dynamically generate methods or attributes.
3. **Framework Development**: Implement ORM frameworks or plugin systems.

#### Example: Adding Attributes Dynamically

```python
class AttributeMeta(type):
    def __new__(cls, name, bases, dct):
        dct['dynamic_attribute'] = "I was added dynamically!"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=AttributeMeta):
    pass

print(MyClass.dynamic_attribute)  # Output: I was added dynamically!
```

---

## Monkey Patching

Monkey patching involves modifying or extending code at runtime by directly changing classes or modules. This can be useful but should be used cautiously as it can lead to unpredictable behavior.

#### Example:

```python
class MyClass:
    def greet(self):
        return "Hello!"

def new_greet(self):
    return "Hi, there!"

MyClass.greet = new_greet  # Monkey patching
obj = MyClass()
print(obj.greet())  # Output: Hi, there!
```

---

## Dynamic Class Creation

Python allows you to create classes dynamically using the `type()` function. This is particularly useful for metaprogramming scenarios.

### Example:

```python
DynamicClass = type("DynamicClass", (object,), {"attr": 42, "method": lambda self: "Hello!"})

obj = DynamicClass()
print(obj.attr)       # Output: 42
print(obj.method())   # Output: Hello!
```

### Parameters of `type()`:
1. **Class Name**: Name of the class.
2. **Base Classes**: Tuple of base classes to inherit from.
3. **Class Dictionary**: Dictionary of attributes and methods.

---

## Practical Use Cases of Metaprogramming

1. **ORMs (Object-Relational Mappers)**:
   - Dynamically map database tables to Python classes.

2. **Framework Development**:
   - Create flexible APIs or plugin systems.

3. **Code Generation**:
   - Automatically generate repetitive boilerplate code.

4. **Validation Systems**:
   - Enforce rules for class attributes and methods.

5. **Testing and Mocking**:
   - Modify or replace objects dynamically for testing purposes.

---

## Best Practices for Metaprogramming

1. **Use Sparingly**:
   - Metaprogramming can make code harder to understand and debug. Use it only when necessary.

2. **Document Clearly**:
   - Clearly explain the purpose and behavior of metaprogramming constructs.

3. **Avoid Overengineering**:
   - Don't use metaprogramming where simpler solutions suffice.

4. **Test Thoroughly**:
   - Ensure that dynamically generated code is thoroughly tested to avoid runtime issues.

5. **Be Cautious with `exec` and `eval`**:
   - Avoid using these functions unless absolutely necessary, and never use them with untrusted input.

---

## Conclusion

Metaprogramming in Python provides powerful tools for creating dynamic, flexible, and reusable code. With features like decorators, metaclasses, and dynamic class creation, Python enables developers to solve complex problems with concise solutions. However, metaprogramming should be used judiciously, as it can make code harder to read and maintain. By following best practices, you can harness the power of metaprogramming effectively.
<a id='new'></a>
# The `__new__` Method in Python

## Introduction

The `__new__` method in Python is a special method responsible for creating a new instance of a class. Unlike `__init__`, which initializes an already created object, `__new__` is called before `__init__` and is responsible for allocating memory for the instance. By overriding `__new__`, you can control the instantiation process, enabling advanced customization and metaprogramming techniques.

This document explores the `__new__` method, its usage, and practical examples.

---

## Syntax of `__new__`

The `__new__` method has the following signature:

```python
def __new__(cls, *args, **kwargs):
    # Custom logic
    return super().__new__(cls)
```

### Parameters:
1. **`cls`**: The class being instantiated (not an instance).
2. **`*args`**: Positional arguments passed during object creation.
3. **`**kwargs`**: Keyword arguments passed during object creation.

The method must return an instance of the class or a subclass; otherwise, a `TypeError` will be raised.

---

## When to Use `__new__`

1. **Immutable Objects**:
   - Required for classes that derive from immutable types like `str`, `tuple`, or `int`.

2. **Singleton Pattern**:
   - To ensure only one instance of a class is created.

3. **Metaprogramming**:
   - Customize or modify instance creation dynamically.

4. **Caching or Reuse**:
   - Return pre-existing objects instead of creating new ones.

---

## Basic Example of `__new__`

### Example:

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print("__new__ called")
        instance = super().__new__(cls)
        return instance

    def __init__(self, value):
        print("__init__ called")
        self.value = value

obj = MyClass(10)
# Output:
# __new__ called
# __init__ called
```

### Explanation:
1. `__new__` is called first to create the instance.
2. `__init__` is then called to initialize the instance.

---

## Advanced Examples of `__new__`

### 1. Customizing Immutable Types

For immutable objects like strings, customization requires overriding `__new__`.

#### Example:

```python
class CustomString(str):
    def __new__(cls, value):
        value = value.upper()  # Modify the string before creation
        return super().__new__(cls, value)

s = CustomString("hello")
print(s)  # Output: HELLO
```

### 2. Singleton Pattern

The Singleton pattern ensures that only one instance of a class is created.

#### Example:

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

obj1 = Singleton()
obj2 = Singleton()
print(obj1 is obj2)  # Output: True
```

### 3. Object Caching

You can use `__new__` to return pre-existing objects instead of creating new ones.

#### Example:

```python
class IntegerCache:
    _cache = {}

    def __new__(cls, value):
        if value in cls._cache:
            return cls._cache[value]
        instance = super().__new__(cls)
        cls._cache[value] = instance
        return instance

    def __init__(self, value):
        self.value = value

obj1 = IntegerCache(10)
obj2 = IntegerCache(10)
print(obj1 is obj2)  # Output: True
```

### 4. Subclass Control

`__new__` can enforce constraints on subclass creation.

#### Example:

```python
class Base:
    def __new__(cls, *args, **kwargs):
        if cls is Base:
            raise TypeError("Base class cannot be instantiated directly")
        return super().__new__(cls)

class Subclass(Base):
    pass

# base = Base()  # Raises TypeError
sub = Subclass()  # Works fine
```

---

## Key Differences Between `__new__` and `__init__`

| **Aspect**               | **`__new__`**                                   | **`__init__`**                                |
|--------------------------|-------------------------------------------------|-----------------------------------------------|
| **Purpose**              | Creates a new instance of the class.           | Initializes the instance after it is created. |
| **When It Is Called**    | Called before `__init__`.                      | Called after `__new__`.                       |
| **Return Value**         | Must return the new instance.                  | Returns `None`.                               |
| **Used For**             | Customizing instantiation.                     | Initializing attributes.                      |
| **Required for Immutables** | Yes.                                          | No.                                            |

---

## Best Practices for Using `__new__`

1. **Use Only When Necessary**:
   - Reserve `__new__` for cases where object creation needs to be customized.

2. **Always Call `super().__new__`**:
   - Ensure proper object creation by calling the parent classâ€™s `__new__` method.

3. **Avoid Overcomplicating**:
   - Use `__init__` for most initialization tasks unless working with immutable types or implementing advanced patterns.

4. **Document Custom Behavior**:
   - Clearly explain why `__new__` is being used to aid maintainability.

---

## Conclusion

The `__new__` method is a powerful tool in Python for customizing object creation. While it is less commonly used than `__init__`, it is essential for working with immutable types, implementing design patterns like Singletons, and controlling object instantiation. By understanding when and how to use `__new__`, developers can leverage Python's flexibility to build advanced, dynamic systems.
<a id='class-creation'></a>
# How Classes Are Created in Python

## Introduction

In Python, classes are the foundation of object-oriented programming (OOP). They define the structure and behavior of objects. Understanding how classes are created in Python requires delving into the mechanics of the class definition process, including how Python executes class code, how it uses the metaclass mechanism, and how it initializes the resulting class object.

This document elaborates on the step-by-step process of class creation in Python, including the roles of the `type` function, metaclasses, and customization techniques.

---

## High-Level Overview

In Python, defining a class involves the following steps:

1. **Class Definition**:
   - Python executes the body of the class as normal code in a separate namespace.

2. **Class Dictionary Creation**:
   - Python collects all attributes and methods defined in the class body into a dictionary.

3. **Metaclass Invocation**:
   - The metaclass (typically `type`) is invoked to create the class object.

4. **Class Object Creation**:
   - The resulting class object is returned and assigned to the class name.

---

## Detailed Steps of Class Creation

### 1. Executing the Class Body

When a class is defined, Python executes the code inside the class block line by line in a new namespace. Any variables, functions, or expressions within the class block are executed as normal Python code.

#### Example:

```python
class Example:
    x = 10

    def method(self):
        return self.x * 2
```

### 2. Collecting the Class Namespace

The attributes and methods defined in the class body are stored in a special dictionary. This dictionary represents the class's namespace.

#### Example:

```python
class Example:
    x = 10

print(Example.__dict__)
# Output: {'__module__': '__main__', 'x': 10, '__dict__': <attribute>, '__weakref__': <attribute>, '__doc__': None}
```

### 3. Invoking the Metaclass

The metaclass is responsible for creating the actual class object. By default, Python uses the `type` metaclass unless a custom metaclass is specified.

#### The Role of `type`

The `type` metaclass creates the class object by combining:
1. The class name.
2. The tuple of base classes (inheritance).
3. The class namespace dictionary.

#### Example:

```python
# Equivalent to: class Example: pass
Example = type("Example", (), {"x": 10})

print(Example)  # Output: <class '__main__.Example'>
print(Example.x)  # Output: 10
```

### 4. Creating the Class Object

Once the metaclass processes the provided information, it returns the class object, which is then assigned to the class name in the enclosing namespace.

---

## Customizing Class Creation

### Custom Metaclasses

A metaclass is a class responsible for defining how other classes behave. You can customize the class creation process by defining your own metaclass and overriding its `__new__` or `__init__` methods.

#### Example:

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        dct["new_attribute"] = "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass

print(MyClass.new_attribute)  # Output: Added by metaclass
```

### Overriding `__new__` in the Metaclass

The `__new__` method in the metaclass controls how the class object itself is created.

#### Example:

```python
class LoggingMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        return super().__new__(cls, name, bases, dct)

class LoggedClass(metaclass=LoggingMeta):
    pass
# Output: Creating class LoggedClass
```

### Using the `__init__` Method in the Metaclass

The `__init__` method in the metaclass is called after the class object is created. It can be used to perform additional initialization steps.

#### Example:

```python
class InitMeta(type):
    def __init__(cls, name, bases, dct):
        print(f"Initializing class {name}")
        super().__init__(name, bases, dct)

class InitializedClass(metaclass=InitMeta):
    pass
# Output: Initializing class InitializedClass
```

---

## Dynamic Class Creation

Python allows dynamic creation of classes using the `type` function. This is particularly useful for metaprogramming and frameworks.

### Example:

```python
# Dynamically creating a class
DynamicClass = type("DynamicClass", (object,), {"attribute": 42})

instance = DynamicClass()
print(instance.attribute)  # Output: 42
```

---

## Class-Level Attributes and Methods

During class creation, special attributes like `__dict__`, `__doc__`, and `__module__` are automatically added. You can also define class-level methods using the `@classmethod` decorator.

#### Example:

```python
class Example:
    @classmethod
    def class_method(cls):
        return f"This is a method of {cls.__name__}"

print(Example.class_method())
# Output: This is a method of Example
```

---

## Best Practices for Class Creation

1. **Use Metaclasses Judiciously**:
   - Metaclasses are powerful but can make code harder to read and maintain. Use them only when necessary.

2. **Document Custom Behavior**:
   - Clearly document any customizations made to the class creation process.

3. **Follow Python Naming Conventions**:
   - Use `CamelCase` for class names and `snake_case` for methods and attributes.

4. **Leverage `type` for Dynamic Behavior**:
   - Use `type` for creating classes dynamically when needed.

---

## Conclusion

Understanding how classes are created in Python, from executing the class body to using metaclasses, is essential for advanced object-oriented programming. By customizing the class creation process with metaclasses or `type`, you can create dynamic, flexible, and powerful Python programs.
<a id='inheriting'></a>
# Inheriting from `type` in Python

## Introduction

In Python, the `type` class is the default metaclass used to create all classes. By inheriting from `type`, you can define custom metaclasses to control the behavior of class creation, attribute access, or other advanced features. Custom metaclasses are a powerful tool in Python's metaprogramming arsenal and allow developers to extend and customize class-level behavior.

This document explores inheriting from `type`, creating custom metaclasses, and practical use cases.

---

## Basics of `type`

The `type` class is both a metaclass and a constructor for class objects. It has two primary roles:

1. **Class Constructor**: When called with three arguments (`type(name, bases, dict)`), it creates a new class object.
2. **Metaclass**: Controls the behavior of class creation.

### Example: Using `type` to Create a Class

```python
MyClass = type("MyClass", (object,), {"attribute": 42, "method": lambda self: "Hello!"})

obj = MyClass()
print(obj.attribute)  # Output: 42
print(obj.method())   # Output: Hello!
```

---

## Creating Custom Metaclasses by Inheriting from `type`

To define a custom metaclass, inherit from `type` and override its special methods, such as `__new__` or `__init__`.

### The Role of `__new__` and `__init__`

- **`__new__`**: Creates and returns the new class object.
- **`__init__`**: Initializes the newly created class object.

### Example: Basic Custom Metaclass

```python
class CustomMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        dct["custom_attribute"] = "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=CustomMeta):
    pass

print(MyClass.custom_attribute)  # Output: Added by metaclass
```

---

## Advanced Customizations

### Adding Validation or Constraints

You can use the `__new__` or `__init__` methods in the metaclass to enforce rules on class definitions.

#### Example:

```python
class ValidatedMeta(type):
    def __new__(cls, name, bases, dct):
        if "required_method" not in dct:
            raise TypeError(f"Class {name} must define a 'required_method'")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=ValidatedMeta):
    def required_method(self):
        pass

# Uncommenting the following code will raise a TypeError
# class InvalidClass(metaclass=ValidatedMeta):
#     pass
```

### Automatically Adding Methods or Attributes

You can dynamically inject attributes or methods into classes during their creation.

#### Example:

```python
class AutoMethodMeta(type):
    def __new__(cls, name, bases, dct):
        dct["auto_method"] = lambda self: "This method was added automatically."
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=AutoMethodMeta):
    pass

obj = MyClass()
print(obj.auto_method())  # Output: This method was added automatically.
```

### Customizing Attribute Access

Override `__getattr__` and `__setattr__` at the metaclass level to control attribute access.

#### Example:

```python
class AttributeControlMeta(type):
    def __setattr__(cls, name, value):
        if name == "immutable_attribute":
            raise AttributeError("This attribute is immutable")
        super().__setattr__(cls, name, value)

class MyClass(metaclass=AttributeControlMeta):
    immutable_attribute = "Initial value"

# Attempting to modify the immutable attribute will raise an error
# MyClass.immutable_attribute = "New value"  # Raises AttributeError
```

---

## Practical Use Cases for Custom Metaclasses

### 1. Singleton Pattern

A metaclass can enforce the Singleton pattern, ensuring only one instance of a class exists.

#### Example:

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class SingletonClass(metaclass=SingletonMeta):
    pass

obj1 = SingletonClass()
obj2 = SingletonClass()
print(obj1 is obj2)  # Output: True
```

### 2. Plugin Systems

Metaclasses can be used to automatically register classes in a plugin system.

#### Example:

```python
class PluginMeta(type):
    plugins = {}

    def __new__(cls, name, bases, dct):
        new_class = super().__new__(cls, name, bases, dct)
        cls.plugins[name] = new_class
        return new_class

class BasePlugin(metaclass=PluginMeta):
    pass

class PluginA(BasePlugin):
    pass

class PluginB(BasePlugin):
    pass

print(PluginMeta.plugins)
# Output: {'BasePlugin': <class '__main__.BasePlugin'>, 'PluginA': <class '__main__.PluginA'>, 'PluginB': <class '__main__.PluginB'>}
```

---

## Best Practices for Using Custom Metaclasses

1. **Use Sparingly**:
   - Metaclasses are powerful but can make code harder to read and maintain. Use them only when necessary.

2. **Document Clearly**:
   - Provide clear documentation for any custom behavior introduced by the metaclass.

3. **Avoid Overcomplication**:
   - Ensure metaclasses do not introduce unnecessary complexity.

4. **Test Thoroughly**:
   - Validate the behavior of metaclasses to avoid unexpected side effects.

5. **Prefer Composition Over Inheritance**:
   - Use composition instead of relying too heavily on metaclasses for advanced behaviors.

---

## Conclusion

Inheriting from `type` enables developers to create custom metaclasses that control and extend the class creation process. By understanding the `__new__` and `__init__` methods and following best practices, you can use custom metaclasses to enforce constraints, add dynamic functionality, and build advanced Python frameworks. However, use them judiciously to maintain readability and simplicity in your codebase.
<a id='metaclass'></a>
# Metaclasses in Python

## Introduction

A metaclass in Python is a class of a class that defines how a class behaves. It is responsible for creating and initializing classes. While classes define the behavior of instances, metaclasses define the behavior of classes themselves. By customizing metaclasses, you can control the creation, initialization, and behavior of classes, making them a powerful tool in Python's metaprogramming capabilities.

This document explores metaclasses, their purpose, how they work, and practical use cases.

---

## Basics of Metaclasses

### What Is a Metaclass?

A metaclass is a class that controls the creation and behavior of other classes. By default, Python uses the built-in `type` metaclass, but you can create custom metaclasses to modify or extend this behavior.

### Key Concepts

1. **Class-Level Behavior**:
   - Metaclasses operate at the class level, not the instance level.

2. **Inheritance from `type`**:
   - A custom metaclass must inherit from `type`.

3. **Special Methods**:
   - Metaclasses override `__new__` and `__init__` to control class creation and initialization.

---

## The Role of `type` as the Default Metaclass

In Python, `type` serves two primary purposes:

1. **Class Constructor**:
   - When called with three arguments (`type(name, bases, dict)`), `type` creates a new class.

2. **Metaclass**:
   - By default, all classes are instances of `type`.

#### Example:

```python
# Creating a class using type
MyClass = type("MyClass", (object,), {"x": 10, "method": lambda self: self.x * 2})

obj = MyClass()
print(obj.x)        # Output: 10
print(obj.method()) # Output: 20
```

---

## Defining a Custom Metaclass

A custom metaclass is created by inheriting from `type` and overriding its special methods, such as `__new__` and `__init__`.

### Example: Basic Custom Metaclass

```python
class CustomMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        dct["custom_attribute"] = "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=CustomMeta):
    pass

print(MyClass.custom_attribute)  # Output: Added by metaclass
```

### Special Methods in Metaclasses

1. **`__new__(cls, name, bases, dct)`**:
   - Responsible for creating the class object.
   - It must return the newly created class.

2. **`__init__(cls, name, bases, dct)`**:
   - Called after the class is created.
   - Used for additional initialization steps.

---

## Practical Use Cases of Metaclasses

### 1. Enforcing Class-Level Constraints

Metaclasses can validate or modify class definitions to ensure they meet certain requirements.

#### Example:

```python
class ValidatedMeta(type):
    def __new__(cls, name, bases, dct):
        if "required_method" not in dct:
            raise TypeError(f"Class {name} must define a 'required_method'")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=ValidatedMeta):
    def required_method(self):
        pass

# Uncommenting the following code will raise a TypeError
# class InvalidClass(metaclass=ValidatedMeta):
#     pass
```

### 2. Automatic Attribute Injection

Metaclasses can add attributes or methods to classes dynamically.

#### Example:

```python
class AutoMethodMeta(type):
    def __new__(cls, name, bases, dct):
        dct["auto_method"] = lambda self: "This method was added automatically."
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=AutoMethodMeta):
    pass

obj = MyClass()
print(obj.auto_method())  # Output: This method was added automatically.
```

### 3. Singleton Pattern

Metaclasses can enforce the Singleton pattern, ensuring only one instance of a class exists.

#### Example:

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class SingletonClass(metaclass=SingletonMeta):
    pass

obj1 = SingletonClass()
obj2 = SingletonClass()
print(obj1 is obj2)  # Output: True
```

### 4. Plugin Registration

Metaclasses can be used to automatically register subclasses for plugin systems.

#### Example:

```python
class PluginMeta(type):
    plugins = {}

    def __new__(cls, name, bases, dct):
        new_class = super().__new__(cls, name, bases, dct)
        cls.plugins[name] = new_class
        return new_class

class BasePlugin(metaclass=PluginMeta):
    pass

class PluginA(BasePlugin):
    pass

class PluginB(BasePlugin):
    pass

print(PluginMeta.plugins)
# Output: {'BasePlugin': <class '__main__.BasePlugin'>, 'PluginA': <class '__main__.PluginA'>, 'PluginB': <class '__main__.PluginB'>}
```

---

## Best Practices for Using Metaclasses

1. **Use Judiciously**:
   - Metaclasses are powerful but can make code harder to understand and maintain. Use them only when necessary.

2. **Document Clearly**:
   - Provide clear documentation for the behavior and purpose of custom metaclasses.

3. **Avoid Overcomplication**:
   - Ensure that the use of metaclasses adds value without introducing unnecessary complexity.

4. **Test Thoroughly**:
   - Metaclasses often involve dynamic behavior. Test thoroughly to avoid unexpected side effects.

5. **Prefer Composition Over Metaclasses**:
   - In many cases, composition can achieve similar results without the complexity of metaclasses.

---

## Conclusion

Metaclasses in Python are a powerful feature for controlling and customizing class creation and behavior. By inheriting from `type` and overriding its methods, you can enforce constraints, inject attributes, and implement advanced patterns like singletons and plugin systems. However, metaclasses should be used judiciously, as they can make code more complex and harder to maintain. By following best practices, you can leverage metaclasses to create flexible and dynamic Python programs.
<a id='class-decorators'></a>
# Class Decorators in Python

## Introduction

Class decorators in Python provide a mechanism to modify or enhance the behavior of a class dynamically. They are similar to function decorators but are applied to entire classes instead of functions. Class decorators are typically used to modify attributes, add methods, enforce rules, or integrate patterns dynamically at the time the class is defined.

This document explores the concept of class decorators, their implementation, use cases, and best practices.

---

## What Are Class Decorators?

A class decorator is a function (or callable object) that takes a class as its argument, performs some operations on it, and returns the modified or original class. The decorator syntax (`@decorator`) can be used to apply a class decorator to a class.

---

## Syntax of a Class Decorator

### Basic Structure

```python
def decorator(cls):
    # Modify the class here
    return cls

@decorator
class MyClass:
    pass
```

In this example:
1. `decorator` is a function that takes `MyClass` as an argument.
2. The decorator modifies or processes `MyClass` and returns it.
3. The `@decorator` syntax applies the decorator to the class.

---

## Examples of Class Decorators

### 1. Adding Attributes to a Class

A decorator can dynamically add attributes to a class.

```python
def add_attributes(cls):
    cls.new_attribute = "Added by decorator"
    return cls

@add_attributes
class MyClass:
    pass

print(MyClass.new_attribute)  # Output: Added by decorator
```

### 2. Adding Methods to a Class

You can also add methods to a class dynamically using a decorator.

```python
def add_method(cls):
    def new_method(self):
        return "This method was added dynamically."
    cls.new_method = new_method
    return cls

@add_method
class MyClass:
    pass

obj = MyClass()
print(obj.new_method())  # Output: This method was added dynamically.
```

### 3. Validating Class Definitions

A decorator can validate the class to ensure it meets certain requirements, such as having specific attributes or methods.

```python
def validate_class(cls):
    if not hasattr(cls, "required_attribute"):
        raise TypeError("Class must define 'required_attribute'")
    return cls

@validate_class
class MyClass:
    required_attribute = "Present"

# Uncommenting the following will raise a TypeError
# @validate_class
# class InvalidClass:
#     pass
```

### 4. Singleton Pattern with a Class Decorator

A decorator can enforce the Singleton pattern by ensuring only one instance of a class is created.

```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class MyClass:
    pass

obj1 = MyClass()
obj2 = MyClass()
print(obj1 is obj2)  # Output: True
```

---

## Using Callable Objects as Class Decorators

Instead of using a function as a class decorator, you can define a callable object by implementing the `__call__` method in a class.

### Example:

```python
class AddMethodDecorator:
    def __call__(self, cls):
        def new_method(self):
            return "Added by callable object."
        cls.new_method = new_method
        return cls

@AddMethodDecorator()
class MyClass:
    pass

obj = MyClass()
print(obj.new_method())  # Output: Added by callable object.
```

---

## Combining Multiple Class Decorators

You can apply multiple decorators to a single class. The decorators are applied in the order they are listed, from bottom to top.

### Example:

```python
def add_attribute(cls):
    cls.attribute = "Attribute added"
    return cls

def add_method(cls):
    def new_method(self):
        return "Method added"
    cls.new_method = new_method
    return cls

@add_attribute
@add_method
class MyClass:
    pass

print(MyClass.attribute)       # Output: Attribute added
print(MyClass().new_method())  # Output: Method added
```

---

## Best Practices for Class Decorators

1. **Keep Decorators Simple**:
   - Avoid introducing complex logic in decorators to maintain readability and ease of debugging.

2. **Document the Behavior**:
   - Clearly document what the decorator does to the class for other developers.

3. **Test Thoroughly**:
   - Ensure that decorators do not introduce unintended side effects, especially when combined.

4. **Use Callable Objects for Reusability**:
   - Implement decorators as callable objects when they need to maintain state or configuration.

5. **Validate Class Definitions**:
   - Use decorators to enforce rules or constraints, such as requiring certain methods or attributes.

---

## Use Cases for Class Decorators

1. **Enforcing Coding Standards**:
   - Validate that a class adheres to specific conventions.

2. **Dynamic Class Enhancement**:
   - Add attributes or methods to a class based on runtime conditions.

3. **Behavioral Modifications**:
   - Modify or extend the behavior of a class without altering its source code.

4. **Design Patterns**:
   - Implement patterns such as Singleton or Factory.

5. **Integration with Frameworks**:
   - Automatically register classes for use in plugins, dependency injection, or other frameworks.

---

## Conclusion

Class decorators are a versatile and powerful feature in Python that allow developers to dynamically modify or enhance class behavior. By understanding their structure, use cases, and best practices, you can write more flexible, reusable, and maintainable code. While they should be used judiciously to avoid overcomplicating your codebase, class decorators are an essential tool in advanced Python programming.
<a id='meta-vs-decorators'></a>
# Metaclass vs Class Decorator in Python

## Introduction

Both metaclasses and class decorators in Python are tools for modifying or enhancing class behavior. However, they operate at different levels and are suited for different use cases. Understanding their differences, similarities, and appropriate usage scenarios is crucial for writing clean, maintainable, and effective Python code.

This document explores the key distinctions, use cases, and examples of metaclasses and class decorators.

---

## What is a Metaclass?

A metaclass is a class that defines the behavior of other classes. It controls how classes are created, initialized, and modified. By default, Python uses the `type` metaclass to create all classes.

### Key Features of Metaclasses:
1. Operate at the class creation level.
2. Can customize the structure and behavior of the class being created.
3. Defined by inheriting from `type`.

#### Example of a Metaclass:

```python
class CustomMeta(type):
    def __new__(cls, name, bases, dct):
        dct['new_attribute'] = "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=CustomMeta):
    pass

print(MyClass.new_attribute)  # Output: Added by metaclass
```

---

## What is a Class Decorator?

A class decorator is a function or callable object that modifies a class after it is defined. It takes the class as an argument, modifies it, and returns the modified class.

### Key Features of Class Decorators:
1. Operate on a fully constructed class object.
2. Are simpler to implement and use compared to metaclasses.
3. Defined using the `@decorator` syntax.

#### Example of a Class Decorator:

```python
def add_attribute(cls):
    cls.new_attribute = "Added by decorator"
    return cls

@add_attribute
class MyClass:
    pass

print(MyClass.new_attribute)  # Output: Added by decorator
```

---

## Differences Between Metaclasses and Class Decorators

| **Aspect**                  | **Metaclass**                                   | **Class Decorator**                            |
|-----------------------------|-------------------------------------------------|------------------------------------------------|
| **Scope of Operation**      | Affects class creation before the class exists. | Operates on the fully constructed class.       |
| **Complexity**              | More complex to implement and use.              | Easier to implement and use.                   |
| **Use Cases**               | Enforcing class-level constraints or behaviors. | Adding or modifying attributes or methods.     |
| **Syntax**                  | Defined with `metaclass` keyword.               | Defined with `@decorator` syntax.              |
| **Reusability**             | Works inherently for subclasses via inheritance.| Must be explicitly applied to each class.      |
| **Flexibility**             | Can modify the class creation process itself.   | Limited to post-creation modifications.        |
| **Performance Impact**      | Can be heavier due to pre-construction logic.   | Lightweight and typically faster.              |

---

## When to Use Metaclasses

Metaclasses are suitable when you need to:

1. **Enforce Class-Level Constraints**:
   - Ensure that a class defines certain attributes or methods.

2. **Customize Class Creation**:
   - Modify or validate a class during its creation process.

3. **Implement Framework Features**:
   - Create plugin systems, ORMs, or other frameworks that rely on dynamic class behavior.

### Example:

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class SingletonClass(metaclass=SingletonMeta):
    pass

obj1 = SingletonClass()
obj2 = SingletonClass()
print(obj1 is obj2)  # Output: True
```

---

## When to Use Class Decorators

Class decorators are suitable when you need to:

1. **Add or Modify Attributes and Methods**:
   - Dynamically inject functionality into a class.

2. **Enforce Simple Constraints**:
   - Validate or modify the class after its creation.

3. **Keep Code Simple and Readable**:
   - Achieve quick modifications without the overhead of metaclasses.

### Example:

```python
def validate_class(cls):
    if not hasattr(cls, "required_attribute"):
        raise TypeError("Class must define 'required_attribute'")
    return cls

@validate_class
class MyClass:
    required_attribute = "Defined"

# Uncommenting the following will raise a TypeError
# @validate_class
# class InvalidClass:
#     pass
```

---

## Combining Metaclasses and Class Decorators

In some cases, you can combine both metaclasses and class decorators for enhanced functionality. Metaclasses handle the class creation process, while class decorators modify the class after it is created.

### Example:

```python
class CustomMeta(type):
    def __new__(cls, name, bases, dct):
        dct['meta_attribute'] = "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

def add_decorator_attribute(cls):
    cls.decorator_attribute = "Added by decorator"
    return cls

@add_decorator_attribute
class MyClass(metaclass=CustomMeta):
    pass

print(MyClass.meta_attribute)       # Output: Added by metaclass
print(MyClass.decorator_attribute)  # Output: Added by decorator
```

---

## Best Practices

1. **Choose the Right Tool**:
   - Use class decorators for simple modifications and metaclasses for advanced use cases.

2. **Avoid Overengineering**:
   - Metaclasses can add unnecessary complexity; use them only when necessary.

3. **Document Behavior**:
   - Clearly document the purpose and behavior of custom metaclasses or decorators.

4. **Test Thoroughly**:
   - Both metaclasses and decorators introduce dynamic behavior, so ensure comprehensive testing.

5. **Combine Judiciously**:
   - When combining both, ensure that their effects are predictable and complementary.

---

## Conclusion

Metaclasses and class decorators are powerful tools in Python for dynamically modifying class behavior. While metaclasses operate at the class creation level and provide advanced customization capabilities, class decorators are simpler and modify fully constructed classes. Understanding their differences and appropriate use cases ensures you can choose the right tool for your programming needs while maintaining clarity and simplicity in your code.
<a id='parameters'></a>
# Metaclass Parameters in Python

## Introduction

A metaclass in Python is responsible for defining and customizing the behavior of classes. Metaclasses are invoked during the class creation process, and they operate by using parameters passed during this process. These parameters provide the metaclass with information about the class being created, allowing for dynamic customization of the class structure, attributes, and methods.

This document elaborates on the parameters of a metaclass and how they can be used to control the class creation process.

---

## The `type.__new__` Signature

The `type` metaclass and custom metaclasses accept the following parameters:

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        # Custom logic here
        return super().__new__(cls, name, bases, dct)
```

### Parameters:
1. **`cls`**:
   - The metaclass itself. This is the class object of the metaclass.

2. **`name`**:
   - A string representing the name of the class being created.

3. **`bases`**:
   - A tuple of base classes (superclasses) of the class being created.

4. **`dct`**:
   - A dictionary containing the class body (attributes, methods, etc.) defined in the class.

---

## Detailed Explanation of Parameters

### 1. `cls`: The Metaclass

This parameter refers to the metaclass itself. When defining a custom metaclass, `cls` is used to ensure proper delegation to the parent `type` class.

#### Example:

```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Metaclass: {cls}")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass

# Output: Metaclass: <class '__main__.MyMeta'>
```

### 2. `name`: The Name of the Class

This parameter specifies the name of the class being created. It allows the metaclass to dynamically alter or validate the class name.

#### Example:

```python
class NameValidationMeta(type):
    def __new__(cls, name, bases, dct):
        if not name.endswith("Class"):
            raise ValueError("Class name must end with 'Class'")
        return super().__new__(cls, name, bases, dct)

# Valid class
class ValidClass(metaclass=NameValidationMeta):
    pass

# Uncommenting the following will raise a ValueError
# class Invalid(metaclass=NameValidationMeta):
#     pass
```

### 3. `bases`: Base Classes

This parameter is a tuple of base classes (superclasses) for the class being created. The metaclass can validate or modify the inheritance hierarchy using this parameter.

#### Example:

```python
class SingleInheritanceMeta(type):
    def __new__(cls, name, bases, dct):
        if len(bases) > 1:
            raise TypeError("Multiple inheritance is not allowed")
        return super().__new__(cls, name, bases, dct)

# Valid class
class SingleBaseClass(metaclass=SingleInheritanceMeta):
    pass

# Uncommenting the following will raise a TypeError
# class MultiBaseClass(SingleBaseClass, object, metaclass=SingleInheritanceMeta):
#     pass
```

### 4. `dct`: Class Dictionary

The `dct` parameter contains all attributes and methods defined in the class body. The metaclass can modify this dictionary before the class is created.

#### Example:

```python
class AddAttributesMeta(type):
    def __new__(cls, name, bases, dct):
        dct["added_attribute"] = "Dynamically added attribute"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=AddAttributesMeta):
    pass

print(MyClass.added_attribute)  # Output: Dynamically added attribute
```

---

## Customizing Class Creation

By manipulating these parameters, you can customize various aspects of the class creation process.

### Example: Enforcing Method Implementation

A metaclass can enforce that a class implements certain methods.

```python
class AbstractMeta(type):
    def __new__(cls, name, bases, dct):
        if "required_method" not in dct:
            raise TypeError(f"Class {name} must define 'required_method'")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=AbstractMeta):
    def required_method(self):
        return "Implemented"

# Uncommenting the following will raise a TypeError
# class IncompleteClass(metaclass=AbstractMeta):
#     pass
```

### Example: Adding Default Base Classes

A metaclass can ensure that a specific base class is always included in the inheritance hierarchy.

```python
class DefaultBase:
    pass

class EnsureBaseMeta(type):
    def __new__(cls, name, bases, dct):
        if DefaultBase not in bases:
            bases = (DefaultBase,) + bases
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=EnsureBaseMeta):
    pass

print(issubclass(MyClass, DefaultBase))  # Output: True
```

---

## Best Practices for Using Metaclass Parameters

1. **Validate Inputs**:
   - Use `name`, `bases`, and `dct` to enforce rules or validate the class definition.

2. **Minimize Complexity**:
   - Avoid overcomplicating the metaclass logic. Keep it focused and maintainable.

3. **Document Customizations**:
   - Clearly document the purpose of any modifications made by the metaclass.

4. **Test Thoroughly**:
   - Metaclasses can have far-reaching effects. Test their behavior with various class definitions.

5. **Use Judiciously**:
   - Use metaclasses only when simpler alternatives (e.g., class decorators) are insufficient.

---

## Conclusion

The parameters of a metaclass (`cls`, `name`, `bases`, `dct`) provide powerful mechanisms for customizing the class creation process. By understanding and leveraging these parameters, developers can implement advanced class behaviors, enforce constraints, and dynamically modify class attributes and methods. While metaclasses are a powerful tool, they should be used judiciously to avoid unnecessary complexity.
<a id='prepare'></a>
# The `__prepare__` Method in Python Metaclasses

## Introduction

The `__prepare__` method in Python is a special method used in metaclasses to customize the creation of the class namespace. It allows developers to control how the namespace (where class attributes and methods are stored) is structured before the class body is executed.

By default, class attributes and methods are stored in an ordinary Python dictionary (`dict`), but `__prepare__` enables the use of custom mapping objects, such as `OrderedDict`, to preserve order or enforce specific constraints on the namespace.

This document explores the purpose, usage, and practical examples of the `__prepare__` method in metaclasses.

---

## The Role of `__prepare__`

When a class is defined using a custom metaclass, the `__prepare__` method is invoked before the class body is executed. It sets up the namespace in which the class body will execute.

### Key Points:
1. **Default Behavior**:
   - If `__prepare__` is not explicitly defined in the metaclass, Python uses a regular `dict` as the namespace.

2. **Customization**:
   - With `__prepare__`, you can provide a custom mapping object (e.g., `OrderedDict`) for the class body namespace.

3. **Execution Order**:
   - `__prepare__` is called first to create the namespace.
   - The class body executes in this namespace.
   - The metaclass's `__new__` and `__init__` methods are called afterward.

---

## Syntax of `__prepare__`

The `__prepare__` method has the following signature:

```python
class MyMeta(type):
    @staticmethod
    def __prepare__(name, bases, **kwargs):
        # Return a custom namespace (e.g., an OrderedDict)
        return {}
```

### Parameters:
1. **`name`**:
   - The name of the class being created.

2. **`bases`**:
   - A tuple of base classes for the class being created.

3. **`**kwargs`**:
   - Additional keyword arguments passed to the class definition (e.g., from the `metaclass` call).

### Return Value:
The method must return a mapping object (e.g., `dict`, `OrderedDict`) to be used as the class namespace.

---

## Example: Preserving Attribute Order

One common use case for `__prepare__` is to preserve the order of attributes and methods defined in the class body.

### Example:

```python
from collections import OrderedDict

class OrderedMeta(type):
    @staticmethod
    def __prepare__(name, bases):
        return OrderedDict()

    def __new__(cls, name, bases, dct):
        print(f"Ordered attributes for class {name}: {list(dct.keys())}")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=OrderedMeta):
    a = 1
    b = 2
    c = 3

# Output: Ordered attributes for class MyClass: ['__module__', '__qualname__', 'a', 'b', 'c']
```

### Explanation:
1. The `__prepare__` method returns an `OrderedDict`.
2. The class body executes in the `OrderedDict` namespace, preserving the order of attribute definitions.
3. The `__new__` method prints the ordered keys.

---

## Example: Enforcing Naming Conventions

The `__prepare__` method can be used to enforce constraints on class attribute names.

### Example:

```python
class ValidatingDict(dict):
    def __setitem__(self, key, value):
        if not key.islower():
            raise ValueError("Class attributes must be lowercase")
        super().__setitem__(key, value)

class ValidationMeta(type):
    @staticmethod
    def __prepare__(name, bases):
        return ValidatingDict()

class MyClass(metaclass=ValidationMeta):
    valid_name = 1
    # InvalidName = 2  # Uncommenting this will raise a ValueError

print(MyClass.valid_name)  # Output: 1
```

### Explanation:
1. The `__prepare__` method returns a custom dictionary (`ValidatingDict`).
2. The custom dictionary enforces that all attribute names are lowercase.
3. Violations of the rule raise an error at class definition time.

---

## Advanced Use Cases

### 1. Adding Default Attributes

The `__prepare__` method can prepopulate the class namespace with default attributes or methods.

#### Example:

```python
class DefaultMeta(type):
    @staticmethod
    def __prepare__(name, bases):
        return {"default_attribute": "This is a default"}

class MyClass(metaclass=DefaultMeta):
    custom_attribute = "Custom value"

print(MyClass.default_attribute)  # Output: This is a default
print(MyClass.custom_attribute)  # Output: Custom value
```

### 2. Collecting Metrics

The `__prepare__` method can collect metrics about the class body, such as the number of attributes or methods defined.

#### Example:

```python
class MetricsMeta(type):
    @staticmethod
    def __prepare__(name, bases):
        return {}

    def __new__(cls, name, bases, dct):
        dct["attribute_count"] = len(dct) - 2  # Exclude __module__ and __qualname__
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MetricsMeta):
    attr1 = 1
    attr2 = 2

print(MyClass.attribute_count)  # Output: 2
```

---

## Best Practices for Using `__prepare__`

1. **Use Purposefully**:
   - Only use `__prepare__` when customization of the namespace is required.

2. **Return a Mapping Object**:
   - Always return a dictionary-like object (e.g., `dict`, `OrderedDict`) from `__prepare__`.

3. **Document Behavior**:
   - Clearly document what the custom namespace does and why it is needed.

4. **Test Thoroughly**:
   - Ensure that custom behavior does not introduce unintended side effects.

5. **Avoid Overcomplication**:
   - Use `__prepare__` judiciously, as overcomplicating namespace logic can make code harder to maintain.

---

## Conclusion

The `__prepare__` method in metaclasses provides a powerful way to customize the namespace used during class creation. By leveraging `__prepare__`, developers can preserve attribute order, enforce naming conventions, add default attributes, or implement other dynamic behaviors. While `__prepare__` is an advanced feature, understanding its use cases and limitations enables more flexible and maintainable metaprogramming in Python.
<a id='read'></a>
# Attribute Read Accessors in Python

## Introduction

In Python, attribute read accessors refer to mechanisms that control how attributes of an object are accessed (i.e., read) when they are retrieved. By defining custom behaviors for attribute access, developers can encapsulate logic, enforce constraints, and dynamically compute values during the attribute retrieval process.

This document explores different ways to implement and use attribute read accessors in Python, focusing on methods such as `__getattr__`, `__getattribute__`, and `property`.

---

## Basic Attribute Access

By default, attributes in Python objects are stored in an instanceâ€™s `__dict__` or a similar internal storage. Accessing an attribute uses the `object.attribute` syntax.

#### Example:

```python
class MyClass:
    def __init__(self):
        self.value = 42

obj = MyClass()
print(obj.value)  # Output: 42
```

---

## Customizing Attribute Read Access

Python provides several ways to customize how attributes are accessed. These include:

1. **Using `property`**
2. **Overriding `__getattr__`**
3. **Overriding `__getattribute__`**

### 1. Using the `property` Function

The `property` function is used to create managed attributes. It allows developers to define methods that are called when an attribute is accessed.

#### Example:

```python
class MyClass:
    def __init__(self):
        self._value = 42

    @property
    def value(self):
        print("Accessing value")
        return self._value

obj = MyClass()
print(obj.value)  # Output: Accessing value
                  #         42
```

### 2. Overriding `__getattr__`

The `__getattr__` method is invoked when an attribute is accessed, but only if the attribute does not exist in the objectâ€™s namespace (e.g., itâ€™s not in `__dict__`).

#### Example:

```python
class MyClass:
    def __getattr__(self, name):
        print(f"Attribute {name} not found, providing default value.")
        return "Default Value"

obj = MyClass()
print(obj.missing_attribute)  # Output: Attribute missing_attribute not found, providing default value.
                              #         Default Value
```

### 3. Overriding `__getattribute__`

The `__getattribute__` method is called for **every attribute access** on an object. It allows you to intercept and customize all attribute reads, but it requires careful use to avoid infinite recursion.

#### Example:

```python
class MyClass:
    def __getattribute__(self, name):
        print(f"Accessing attribute {name}")
        return super().__getattribute__(name)

    def __init__(self):
        self.value = 42

obj = MyClass()
print(obj.value)  # Output: Accessing attribute value
                  #         42
```

---

## Differences Between `__getattr__` and `__getattribute__`

| Aspect                   | `__getattr__`                              | `__getattribute__`                         |
|--------------------------|--------------------------------------------|--------------------------------------------|
| **Invocation**           | Called only for missing attributes.       | Called for every attribute access.         |
| **Use Case**             | Providing default values for attributes.  | Intercepting and customizing all accesses. |
| **Risk**                 | Minimal risk of infinite recursion.       | High risk of infinite recursion if not used properly. |

#### Example:

```python
class MyClass:
    def __getattr__(self, name):
        return f"{name} does not exist."

    def __getattribute__(self, name):
        print(f"Attempting to access {name}")
        return super().__getattribute__(name)

obj = MyClass()
obj.value = 42
print(obj.value)          # Output: Attempting to access value
                          #         42
print(obj.undefined)      # Output: Attempting to access undefined
                          #         undefined does not exist.
```

---

## Combining `property`, `__getattr__`, and `__getattribute__`

You can combine these methods for fine-grained control over attribute access, but it requires careful planning to avoid conflicts or redundant logic.

#### Example:

```python
class MyClass:
    def __init__(self):
        self._value = 42

    @property
    def value(self):
        print("Accessing managed attribute 'value'")
        return self._value

    def __getattr__(self, name):
        print(f"'{name}' not found, returning default")
        return "Default Value"

    def __getattribute__(self, name):
        print(f"Intercepting access to {name}")
        return super().__getattribute__(name)

obj = MyClass()
print(obj.value)           # Output: Intercepting access to value
                           #         Accessing managed attribute 'value'
                           #         42
print(obj.undefined_attr)  # Output: Intercepting access to undefined_attr
                           #         'undefined_attr' not found, returning default
```

---

## Best Practices for Attribute Read Accessors

1. **Use `property` for Managed Attributes**:
   - Prefer `property` for managing specific attributes.

2. **Reserve `__getattr__` for Missing Attributes**:
   - Use `__getattr__` sparingly to handle missing attributes or provide defaults.

3. **Be Cautious with `__getattribute__`**:
   - Avoid unnecessary overrides to minimize performance overhead and recursion risks.

4. **Test Thoroughly**:
   - Ensure custom behavior does not unintentionally interfere with normal attribute access.

5. **Document Clearly**:
   - Explain why custom accessors are used to aid maintainability.

---

## Conclusion

Attribute read accessors (`property`, `__getattr__`, and `__getattribute__`) provide powerful tools for customizing how attributes are accessed in Python. By understanding their differences and use cases, developers can write more flexible and maintainable code. While these tools offer significant flexibility, they should be used judiciously to avoid introducing unnecessary complexity.
<a id='write'></a>

# Attribute Write Accessors in Python

## Introduction

Attribute write accessors in Python refer to mechanisms that allow developers to control, validate, or modify the behavior of setting attributes on an object. By defining custom logic for attribute assignment, developers can enforce constraints, implement derived properties, and ensure consistency within their objects.

This document explores various approaches to implement and use attribute write accessors, focusing on methods like `property`, `__setattr__`, and descriptors.

---

## Basic Attribute Assignment

By default, Python allows direct assignment of attributes to an object's namespace. These attributes are typically stored in the instance's `__dict__`.

#### Example:

```python
class MyClass:
    pass

obj = MyClass()
obj.value = 42
print(obj.value)  # Output: 42
```

---

## Customizing Attribute Write Access

Python provides several mechanisms to control attribute assignment:

1. **Using `property` with a Setter**
2. **Overriding `__setattr__`**
3. **Using Descriptors**

### 1. Using `property` with a Setter

The `property` function allows defining managed attributes. A `@property` decorator is used for attribute access, and the `@<property_name>.setter` decorator is used for attribute assignment.

#### Example:

```python
class MyClass:
    def __init__(self):
        self._value = 0

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        if new_value < 0:
            raise ValueError("Value must be non-negative")
        self._value = new_value

obj = MyClass()
obj.value = 10
print(obj.value)  # Output: 10

# Uncommenting the following line will raise a ValueError
# obj.value = -5
```

### 2. Overriding `__setattr__`

The `__setattr__` method is invoked whenever an attribute is assigned to an object. Overriding this method allows customization of all attribute assignments.

#### Example:

```python
class MyClass:
    def __setattr__(self, name, value):
        if name == "value" and value < 0:
            raise ValueError("Value must be non-negative")
        super().__setattr__(name, value)

obj = MyClass()
obj.value = 42
print(obj.value)  # Output: 42

# Uncommenting the following line will raise a ValueError
# obj.value = -10
```

#### Key Points:
- `__setattr__` is called for **every attribute assignment**.
- To avoid infinite recursion, use `super().__setattr__(name, value)` to perform the actual assignment.

### 3. Using Descriptors

Descriptors provide a reusable way to define custom behavior for attribute access, assignment, and deletion by defining methods like `__set__` and `__get__`.

#### Example:

```python
class PositiveValue:
    def __init__(self):
        self._value = 0

    def __get__(self, instance, owner):
        return self._value

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("Value must be non-negative")
        self._value = value

class MyClass:
    value = PositiveValue()

obj = MyClass()
obj.value = 100
print(obj.value)  # Output: 100

# Uncommenting the following line will raise a ValueError
# obj.value = -50
```

#### Key Points:
- Descriptors enable reusable logic for attribute management.
- The `__set__` method is used to customize write behavior.

---

## Differences Between `property`, `__setattr__`, and Descriptors

| **Aspect**                  | **`property`**                         | **`__setattr__`**                         | **Descriptors**                       |
|-----------------------------|-----------------------------------------|-------------------------------------------|----------------------------------------|
| **Scope**                   | For specific attributes.               | For all attributes in the object.         | Reusable for multiple attributes.      |
| **Use Case**                | Simple and focused attribute control.  | Broad, object-wide control.               | Reusable attribute management logic.   |
| **Complexity**              | Easy to implement.                     | Medium complexity, affects all attributes.| Medium to high, requires descriptor class. |

---

## Combining Techniques

You can combine these techniques for greater flexibility and control. For example, use `__setattr__` for global checks and `property` for fine-grained control over specific attributes.

#### Example:

```python
class MyClass:
    def __init__(self):
        self._value = 0

    def __setattr__(self, name, value):
        print(f"Setting attribute {name} to {value}")
        super().__setattr__(name, value)

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        if new_value < 0:
            raise ValueError("Value must be non-negative")
        self._value = new_value

obj = MyClass()
obj.value = 50  # Output: Setting attribute _value to 50
print(obj.value)  # Output: 50
```

---

## Best Practices for Attribute Write Accessors

1. **Use `property` for Simplicity**:
   - Prefer `property` for managing specific attributes, especially when the logic is simple.

2. **Reserve `__setattr__` for Broad Control**:
   - Use `__setattr__` when you need to manage all attribute assignments dynamically.

3. **Leverage Descriptors for Reusability**:
   - Use descriptors to encapsulate attribute logic that needs to be reused across multiple classes or attributes.

4. **Avoid Overcomplication**:
   - Do not overuse these mechanisms unnecessarily. Use the simplest approach that meets your needs.

5. **Document Clearly**:
   - Provide clear explanations for why custom accessors are used to ensure maintainability.

6. **Test Thoroughly**:
   - Ensure custom behavior works as expected under all scenarios, including edge cases.

---

## Conclusion

Attribute write accessors provide powerful mechanisms for controlling how attributes are set in Python. By using `property`, `__setattr__`, and descriptors, developers can encapsulate logic, enforce constraints, and implement reusable patterns for managing attributes. Understanding these tools and their appropriate use cases ensures that you can write robust, maintainable, and efficient code.
